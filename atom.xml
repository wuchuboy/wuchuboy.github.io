<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梧杵</title>
  
  <subtitle>日常学习记录</subtitle>
  <link href="https://wuchu.site/atom.xml" rel="self"/>
  
  <link href="https://wuchu.site/"/>
  <updated>2024-10-29T13:25:18.662Z</updated>
  <id>https://wuchu.site/</id>
  
  <author>
    <name>吴楚</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>checkpoint是什么东西？一个点吗？一个位置？还是一个操作？</title>
    <link href="https://wuchu.site/2024/10/29/checkpoint/"/>
    <id>https://wuchu.site/2024/10/29/checkpoint/</id>
    <published>2024-10-29T11:05:11.000Z</published>
    <updated>2024-10-29T13:25:18.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h3><ul><li><strong>WAL 日志就这么一直写下去，子子孙孙无穷匮也，磁盘不炸了吗</strong></li><li><strong>我怎么知道数据库什么时候崩的？恢复的时候，WAL 日志应该从哪开始重放呢？</strong></li><li><strong>checkpoint是什么东西？一个点吗？一个位置？还是一个操作？</strong></li></ul><h3 id="2、checkpoint"><a href="#2、checkpoint" class="headerlink" title="2、checkpoint"></a>2、checkpoint</h3><p>checkpoint是一个<strong>操作</strong>，执行这个操作的开始时刻，会记录当前开始时刻的 WAL 位置作为<strong>重做点</strong>，这个位置会被保存在文件中。 然后将该<strong>重做点之前</strong>所有 shared buffer 中的脏页均被刷入到存储。checkpoint又名检查点，<strong>一般checkpoint会将某个时间点之前的脏数据全部刷新到磁盘，以实现数据的一致性与完整性。</strong><br>目前各个流行的关系型数据库都具备checkpoint功能，其主要目的是为了缩短崩溃恢复时间，以Oracle为例，在进行数据恢复时，会以最近的checkpoint为参考点执行事务前滚。PostgreSQL在崩溃恢复时会以最近的checkpoint为基础，不断应用这之后的WAL日志。<br>简单来说：</p><ul><li><strong>确保数据一致性：</strong>定期将内存中的脏页写入磁盘，确保数据库的一致性。</li><li><strong>加速崩溃恢复：</strong>减少需要重放的 WAL 日志量，从而加速系统崩溃后的恢复过程。</li><li><strong>控制 WAL 日志大小：</strong>通过记录检查点，限制 WAL 日志的增长，优化存储使用。</li></ul><h3 id="3、怎么触发checkpoint？"><a href="#3、怎么触发checkpoint？" class="headerlink" title="3、怎么触发checkpoint？"></a>3、怎么触发checkpoint？</h3><p>分析源码，发现在<code>src/include/access/xlog.h</code>定义了几类触发的场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECKPOINT_IS_SHUTDOWN0x0001<span class="comment">/* 数据库关闭 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECKPOINT_END_OF_RECOVERY0x0002<span class="comment">/* 数据库恢复结束时触发 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECKPOINT_IMMEDIATE0x0004<span class="comment">/* 立即执行检查点操作，不进行延迟 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECKPOINT_FORCE0x0008<span class="comment">/* 强制执行检查点 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECKPOINT_FLUSH_ALL0x0010<span class="comment">/* 刷新所有页面，包括未记录表的页面 */</span></span></span><br><span class="line"><span class="comment">/* 以下标志对 RequestCheckpoint 函数非常重要 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECKPOINT_WAIT0x0020<span class="comment">/* 等待检查点操作完成 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECKPOINT_REQUESTED0x0040<span class="comment">/* 已发出检查点请求 */</span></span></span><br><span class="line"><span class="comment">/* 以下标志指示检查点请求的原因 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECKPOINT_CAUSE_XLOG0x0080<span class="comment">/* XLOG日志量达到一定程度触发 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECKPOINT_CAUSE_TIME0x0100<span class="comment">/* 周期性触发 */</span></span></span><br></pre></td></tr></table></figure><p>根据上述定义，也就是说，以下几种情况会触发PG数据库操作系统做检查点操作：</p><ol><li>超级用户（其他用户不可）执行CHECKPOINT命令</li><li>数据库shutdown</li><li>数据库recovery完成</li><li>XLOG日志量达到了触发checkpoint阈值</li><li>周期性地进行checkpoint</li><li>需要刷新所有脏页</li></ol><p>为了能够周期性的创建检查点，减少崩溃恢复时间，同时合并I&#x2F;O，PostgreSQL提供了<em>辅助进程checkpointer</em>。它会对不断检测周期时间以及上面的XLOG日志量阈值是否达到，而周期时间以及XLOG日志量阈值可以通过参数来设置大小，接下来介绍下与checkpoints相关的参数。</p><p><code>checkpoint_segments</code>：WAL log的最大数量，系统默认值是3。超过该数量的WAL日志，会自动触发checkpoint。<br><code>checkpoint_timeout</code>：系统自动执行checkpoint之间的最大时间间隔。系统默认值是5分钟。<br><code>checkpoint_completion_target</code>：该参数表示checkpoint的完成时间占两次checkpoint时间间隔的比例，系统默认值是0.5,也就是说每个checkpoint需要在checkpoints间隔时间的50%内完成。<br><code>checkpoint_warning</code>：系统默认值是30秒，如果checkpoints的实际发生间隔小于该参数，将会在server log中写入写入一条相关信息。可以通过设置为0禁用。</p><h3 id="4、checkpoint-操作的过程"><a href="#4、checkpoint-操作的过程" class="headerlink" title="4、checkpoint 操作的过程"></a>4、checkpoint 操作的过程</h3><img src="/2024/10/29/checkpoint/image.png" class="" title="图1"><p><strong>checkpoint操作执行的过程</strong>：</p><p>假设要执行三条insert语句</p><ul><li>checkpoint 操作首先记录下 checkpoint 的开始位置，记录为 <strong>redo point</strong>（重做位点）</li><li>checkpoint 将 shared buffer 中的数据刷到磁盘里面去</li><li>这时候数据库又来了一条 SQL insert 3</li><li>checkpoint 刷脏结束，redo point 之前的数据均已被刷到磁盘存储（数据1和2）</li><li>每个检查点后，第一次数据页的变化会导致整个页面会被记录在XLOG日志中</li></ul><blockquote><p>这时候假如开始数据库恢复，那么数据库会从<code>pg_control</code> 文件中找到最新的 checkpoint 位置，再从 checkpoint 找到 redo point 的位置，开始重放日志。不难看出，1 和 2 这两个数据在 checkpoint 中已经持久化到磁盘存储，WAL 日志中也只有 INSERT 3 操作需要重放。<br><code>ControlFileData</code> 结构定义了<code>pg_control</code>文件中存储的数据格式。这个结构位于 <code>src/include/catalog/pg_control.h </code>文件中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ControlFileData</span></span><br><span class="line">&#123;</span><br><span class="line">    uint32      system_identifier; <span class="comment">/* 唯一的系统标识符，用于区分不同的数据库实例 */</span></span><br><span class="line">    uint32      pg_control_version; <span class="comment">/* pg_control 文件的版本号 */</span></span><br><span class="line">    uint32      catalog_version_no; <span class="comment">/* 数据库的目录版本号 */</span></span><br><span class="line">    DBState     state;              <span class="comment">/* 数据库的当前状态 */</span></span><br><span class="line">    <span class="type">pg_time_t</span>   time;               <span class="comment">/* 最后一次更新的时间戳 */</span></span><br><span class="line">    XLogRecPtr  checkPoint;         <span class="comment">/* 最后一个检查点的 WAL（Write-Ahead Logging）记录指针 */</span></span><br><span class="line">    XLogRecPtr  prevCheckPoint;     <span class="comment">/* 上一个检查点的 WAL 记录指针 */</span></span><br><span class="line">    CheckPoint  checkPointCopy;     <span class="comment">/* 最后一个检查点记录的副本 */</span></span><br><span class="line">    XLogRecPtr  unloggedLSN;        <span class="comment">/* 当前未记录的 LSN（日志序列号） */</span></span><br><span class="line">    <span class="comment">// 其他字段省略</span></span><br><span class="line">&#125; ControlFileData;</span><br></pre></td></tr></table></figure><p>读取和写入 <code>pg_control</code> 文件的主要函数<code>ReadControlFile</code>、<code>UpdateControlFile</code>位于<code>src/backend/access/transam/xlog.c</code> 文件中。</p><p>查看源码，发现<strong>检查点机制的主要实现</strong>位于 <code>src/backend/postmaster/checkpointer.c</code> 文件中。以下是一些关键函数和它们的作用：<br><code>CheckpointerMain</code>：检查点进程的主函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckpointerMain</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化和设置信号处理</span></span><br><span class="line">    <span class="built_in">pqsignal</span>(SIGHUP, SignalHandlerForConfigReload);</span><br><span class="line">    <span class="built_in">pqsignal</span>(SIGINT, SignalHandlerForShutdownRequest);</span><br><span class="line">    <span class="built_in">pqsignal</span>(SIGTERM, SignalHandlerForShutdownRequest);</span><br><span class="line">    <span class="built_in">pqsignal</span>(SIGQUIT, SignalHandlerForCrashRequest);</span><br><span class="line">    <span class="built_in">pqsignal</span>(SIGUSR1, SignalHandlerForCheckpointRequest);</span><br><span class="line">    <span class="built_in">pqsignal</span>(SIGUSR2, SignalHandlerForCheckpointRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 等待检查点请求或超时</span></span><br><span class="line">        <span class="built_in">WaitLatchOrSocket</span>(MyLatch, WL_LATCH_SET | WL_TIMEOUT | WL_POSTMASTER_DEATH, <span class="number">-1</span>, WAIT_EVENT_CHECKPOINTER_MAIN);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理检查点请求</span></span><br><span class="line">        <span class="keyword">if</span> (got_SIGHUP)</span><br><span class="line">        &#123;</span><br><span class="line">            got_SIGHUP = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">ProcessConfigFile</span>(PGC_SIGHUP);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shutdown_requested)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CreateCheckPoint</span>(CHECKPOINT_IS_SHUTDOWN | CHECKPOINT_IMMEDIATE);</span><br><span class="line">            <span class="built_in">proc_exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkpoint_requested)</span><br><span class="line">        &#123;</span><br><span class="line">            checkpoint_requested = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">CreateCheckPoint</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CreateCheckPoint</code>：执行检查点操作的核心函数，负责将脏页写入磁盘并记录检查点信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateCheckPoint</span><span class="params">(<span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CheckPoint  checkpoint;</span><br><span class="line">    XLogRecPtr  recptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检查点结构</span></span><br><span class="line">    <span class="built_in">MemSet</span>(&amp;checkpoint, <span class="number">0</span>, <span class="built_in">sizeof</span>(CheckPoint));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前 WAL 位置</span></span><br><span class="line">    recptr = <span class="built_in">GetInsertRecPtr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将脏页写入磁盘</span></span><br><span class="line">    <span class="built_in">CheckPointBuffers</span>(flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录检查点信息到 WAL 日志</span></span><br><span class="line">    recptr = <span class="built_in">XLogInsert</span>(RM_XLOG_ID, XLOG_CHECKPOINT_SHUTDOWN, &amp;checkpoint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新控制文件</span></span><br><span class="line">    <span class="built_in">UpdateControlFile</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CheckPointBuffers</code>：将脏页写入磁盘。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckPointBuffers</span><span class="params">(<span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num_to_write;</span><br><span class="line">    <span class="type">int</span> num_written;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算需要写入的脏页数量</span></span><br><span class="line">    num_to_write = <span class="built_in">GetNumDirtyBuffers</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入脏页</span></span><br><span class="line">    num_written = <span class="built_in">WriteDirtyBuffers</span>(num_to_write);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (num_written &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">SyncDataDirectory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CheckPointWriteDelay</code>：控制写入速率，避免 I&#x2F;O 峰值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckPointWriteDelay</span><span class="params">(<span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> checkpoint_write_delay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算写入延迟</span></span><br><span class="line">    <span class="keyword">if</span> (checkpoint_write_delay &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">pg_usleep</span>(checkpoint_write_delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><ul><li>checkpoint中记录了 redo point，标记 redo point 之前的数据均已刷脏，完成持久化存储</li><li>标记 redo point 之前的 WAL 日志可以被清理回收</li><li>每个检查点后，第一次数据页的变化会导致整个页面会被记录在XLOG日志中。</li><li>检查点的开销比较高，可以用checkpoint_warning自检，相应调大checkpoint_segments</li><li>检查点的位置保存在文件 pg_control，pg_control文件被损坏可能会导致数据库不可用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;headerlink&quot; title=&quot;1、背景&quot;&gt;&lt;/a&gt;1、背景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WAL 日志就这么一直写下去，子子孙孙无穷匮也，磁盘不炸了吗&lt;/strong&gt;&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://wuchu.site/categories/PostgreSQL/"/>
    
    
    <category term="checkpoint" scheme="https://wuchu.site/tags/checkpoint/"/>
    
  </entry>
  
  <entry>
    <title>使用CTE 实现递归搜索</title>
    <link href="https://wuchu.site/2024/10/29/cte/"/>
    <id>https://wuchu.site/2024/10/29/cte/</id>
    <published>2024-10-29T11:05:11.000Z</published>
    <updated>2024-10-29T11:11:44.881Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、假设我们有一个表示中国城市层次结构的表 <code>cities</code>，其结构如下：</strong></p><ul><li><code>id</code>：城市的唯一标识符</li><li><code>name</code>：城市的名称</li><li><code>parent_id</code>：父城市的唯一标识符（省级城市的 <code>parent_id</code> 为 <code>NULL</code>）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities (</span><br><span class="line">  id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  parent_id <span class="type">INT</span> <span class="keyword">REFERENCES</span> cities(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>2、假设我们有以下数据：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (name, parent_id) <span class="keyword">VALUES</span> (<span class="string">&#x27;中国&#x27;</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (name, parent_id) <span class="keyword">VALUES</span> (<span class="string">&#x27;北京&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (name, parent_id) <span class="keyword">VALUES</span> (<span class="string">&#x27;上海&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (name, parent_id) <span class="keyword">VALUES</span> (<span class="string">&#x27;广东省&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (name, parent_id) <span class="keyword">VALUES</span> (<span class="string">&#x27;广州市&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (name, parent_id) <span class="keyword">VALUES</span> (<span class="string">&#x27;深圳市&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (name, parent_id) <span class="keyword">VALUES</span> (<span class="string">&#x27;天河区&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (name, parent_id) <span class="keyword">VALUES</span> (<span class="string">&#x27;南山区&#x27;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> id <span class="operator">|</span>  name  <span class="operator">|</span> parent_id </span><br><span class="line"><span class="comment">----+--------+-----------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span> 中国    <span class="operator">|</span>          </span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span> 北京    <span class="operator">|</span>         <span class="number">1</span></span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span> 上海    <span class="operator">|</span>         <span class="number">1</span></span><br><span class="line">  <span class="number">4</span> <span class="operator">|</span> 广东省  <span class="operator">|</span>         <span class="number">1</span></span><br><span class="line">  <span class="number">5</span> <span class="operator">|</span> 广州市  <span class="operator">|</span>         <span class="number">4</span></span><br><span class="line">  <span class="number">6</span> <span class="operator">|</span> 深圳市  <span class="operator">|</span>         <span class="number">4</span></span><br><span class="line">  <span class="number">7</span> <span class="operator">|</span> 天河区  <span class="operator">|</span>         <span class="number">5</span></span><br><span class="line">  <span class="number">8</span> <span class="operator">|</span> 南山区  <span class="operator">|</span>         <span class="number">6</span></span><br><span class="line">(<span class="number">8</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p><strong>3、假设我们希望查询 <code>广东省</code> 及其所有子城市的层次结构。并得到以下结果：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> id <span class="operator">|</span>  name  <span class="operator">|</span> parent_id <span class="operator">|</span>            full_path            </span><br><span class="line"><span class="comment">----+--------+-----------+---------------------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span> 中国    <span class="operator">|</span>           <span class="operator">|</span> 中国</span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span> 北京    <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span> 中国 <span class="operator">&gt;</span> 北京</span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span> 上海    <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span> 中国 <span class="operator">&gt;</span> 上海</span><br><span class="line">  <span class="number">4</span> <span class="operator">|</span> 广东省  <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span> 中国 <span class="operator">&gt;</span> 广东省</span><br><span class="line">  <span class="number">5</span> <span class="operator">|</span> 广州市  <span class="operator">|</span>         <span class="number">4</span> <span class="operator">|</span> 中国 <span class="operator">&gt;</span> 广东省 <span class="operator">&gt;</span> 广州市</span><br><span class="line">  <span class="number">6</span> <span class="operator">|</span> 深圳市  <span class="operator">|</span>         <span class="number">4</span> <span class="operator">|</span> 中国 <span class="operator">&gt;</span> 广东省 <span class="operator">&gt;</span> 深圳市</span><br><span class="line">  <span class="number">7</span> <span class="operator">|</span> 天河区  <span class="operator">|</span>         <span class="number">5</span> <span class="operator">|</span> 中国 <span class="operator">&gt;</span> 广东省 <span class="operator">&gt;</span> 广州市 <span class="operator">&gt;</span> 天河区</span><br><span class="line">  <span class="number">8</span> <span class="operator">|</span> 南山区  <span class="operator">|</span>         <span class="number">6</span> <span class="operator">|</span> 中国 <span class="operator">&gt;</span> 广东省 <span class="operator">&gt;</span> 深圳市 <span class="operator">&gt;</span> 南山区</span><br><span class="line">(<span class="number">8</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p><strong>4、我们可以使用递归 CTE 来实现这一点。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> city_hierarchy <span class="keyword">AS</span> (</span><br><span class="line">  <span class="comment">-- 基础查询：选择根节点，并初始化路径</span></span><br><span class="line">  <span class="keyword">SELECT</span> id, name, parent_id, name::<span class="type">VARCHAR</span> <span class="keyword">AS</span> full_path</span><br><span class="line">  <span class="keyword">FROM</span> cities</span><br><span class="line">  <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;中国&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 递归查询：选择子节点，并构建路径</span></span><br><span class="line">  <span class="keyword">SELECT</span> c.id, c.name, c.parent_id, (ch.full_path <span class="operator">||</span> <span class="string">&#x27; &gt; &#x27;</span> <span class="operator">||</span> c.name)::<span class="type">VARCHAR</span> <span class="keyword">AS</span> full_path</span><br><span class="line">  <span class="keyword">FROM</span> cities c</span><br><span class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> city_hierarchy ch <span class="keyword">ON</span> c.parent_id <span class="operator">=</span> ch.id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> city_hierarchy;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1、假设我们有一个表示中国城市层次结构的表 &lt;code&gt;cities&lt;/code&gt;，其结构如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt;：城市的唯一标识符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;：城市的名称&lt;</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://wuchu.site/categories/PostgreSQL/"/>
    
    
    <category term="CTE" scheme="https://wuchu.site/tags/CTE/"/>
    
    <category term="SQL" scheme="https://wuchu.site/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>使用CVM搭建PostgreSQL主从架构</title>
    <link href="https://wuchu.site/2024/10/29/cvm_create_m_s/"/>
    <id>https://wuchu.site/2024/10/29/cvm_create_m_s/</id>
    <published>2024-10-29T11:05:11.000Z</published>
    <updated>2024-10-29T11:52:23.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用CVM搭建-PostgreSQL-主从架构"><a href="#使用CVM搭建-PostgreSQL-主从架构" class="headerlink" title="使用CVM搭建 PostgreSQL 主从架构"></a>使用CVM搭建 PostgreSQL 主从架构</h2><blockquote><p>PostgreSQL 是一个开源对象关系型数据库管理系统，并侧重于可扩展性和标准的符合性。PostgreSQL 面向企业复杂 SQL 处理的 OLTP 在线事务处理场景，支持 NoSQL 数据类型（JSON&#x2F;XML&#x2F;hstore），支持 GIS（Geographic Information System 或 Geo－Information system）地理信息处理，在可靠性、数据完整性方面有良好声誉，适用于互联网网站、位置应用系统、复杂数据对象处理等应用场景。</p></blockquote><h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><p>本文搭建的 PostgreSQL 组成及版本使用说明如下：</p><ul><li><p>Linux：Linux 操作系统，本文以 CentOS 7.6 为例。</p></li><li><p>PostgreSQL：关系型数据库管理系统，本文以 PostgreSQL 12 为例。</p></li></ul><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li><p>已创建两台云服务器实例（一台云服务器实例作为主节点，另一台云服务器实例作为从节点）。</p></li><li><p>新建的两台云服务器实例已配置安全组规则：放通5432端口。</p></li></ul><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1、配置主节点"><a href="#1、配置主节点" class="headerlink" title="1、配置主节点"></a>1、配置主节点</h3><p>登录主节点实例，执行以下命令，升级所有包、系统版本和内核。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update <span class="literal">-y</span></span><br></pre></td></tr></table></figure><p>依次执行以下命令，安装 PostgreSQL。（本文以使用 PostgreSQL 12 版本为例）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wget</span> <span class="literal">--no-check-certificate</span> https://download.postgresql.org/pub/repos/yum/reporpms/EL<span class="literal">-7-x86_64</span>/pgdg<span class="literal">-redhat-repo-latest</span>.noarch.rpm</span><br><span class="line">rpm <span class="literal">-ivh</span> pgdg<span class="literal">-redhat-repo-latest</span>.noarch.rpm</span><br><span class="line">yum install postgresql12<span class="literal">-server</span> postgresql12<span class="literal">-contrib</span> <span class="literal">-y</span></span><br><span class="line">/usr/pgsql<span class="literal">-12</span>/bin/postgresql12<span class="literal">-setup</span> initdb</span><br></pre></td></tr></table></figure><p>执行以下命令，启动服务。﻿</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">start</span> postgresql<span class="literal">-12</span>.service</span><br></pre></td></tr></table></figure><p>执行以下命令，设置服务开机自启动。﻿</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable postgresql<span class="literal">-12</span>.service </span><br></pre></td></tr></table></figure><p>执行以下命令，登录 postgres 用户。﻿</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - postgres</span><br></pre></td></tr></table></figure><p>执行以下命令，进入 PostgreSQL 交互终端。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql</span><br></pre></td></tr></table></figure><p>执行以下命令，为用户 postgres 设置密码，增强安全性。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> postgres <span class="keyword">WITH</span> <span class="keyword">PASSWORD</span> <span class="string">&#x27;*******&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行以下命令，创建数据库账号，并设置密码及登录权限和备份权限。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">role</span> 账户名 <span class="keyword">login</span> <span class="keyword">replication</span> <span class="keyword">encrypted</span> <span class="keyword">password</span> <span class="string">&#x27;自定义密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>本文以创建数据库账号 replica，密码 ****** 为例，则执行以下命令。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">role</span> <span class="keyword">replica</span> <span class="keyword">login</span> <span class="keyword">replication</span> <span class="keyword">encrypted</span> <span class="keyword">password</span> <span class="string">&#x27;******&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行以下命令，查询账号是否创建成功。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> usename <span class="keyword">from</span> pg_user;</span><br></pre></td></tr></table></figure><p>返回如下结果，表示已创建成功。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usename  </span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">postgres</span><br><span class="line"><span class="keyword">replica</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>执行以下命令，查询权限是否创建成功。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> rolname <span class="keyword">from</span> pg_roles;</span><br></pre></td></tr></table></figure><p>返回如下结果，表示已创建成功。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rolname      </span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line">pg_signal_backend</span><br><span class="line">postgres</span><br><span class="line"><span class="keyword">replica</span></span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>输入 <strong>\q</strong>，按 <strong>Enter</strong>，退出 SQL 终端。</p><p>输入 <strong>exit</strong>，按 <strong>Enter</strong>，退出 PostgreSQL。</p><p>执行以下命令，打开 pg_hba.conf 配置文件，设置 replica 用户白名单。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/pgsql/<span class="number">12</span>/data/pg_hba.conf</span><br></pre></td></tr></table></figure><p>按 i 切换至编辑模式，在 IPv4 local connections 段添加如下两行内容：</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host    <span class="keyword">all</span>             <span class="keyword">all</span>         &lt;从节点的VPC IPv4网段&gt;          md5     #允许 VPC 网段中 md5 密码认证连接</span><br><span class="line">host    <span class="keyword">replication</span>     <span class="keyword">replica</span>     &lt;从节点的VPC IPv4网段&gt;          md5     #允许用户从 <span class="keyword">replication</span> 数据库进行数据同步</span><br></pre></td></tr></table></figure><p>例如，数据库账号为 replica，从节点的 VPC IPv4 网段为 xx.xx.xx.xx&#x2F;16，则在 IPv4 local connections 段添加如下内容：</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host    <span class="keyword">all</span>             <span class="keyword">all</span>             xx.xx.xx.xx/<span class="number">16</span>         md5</span><br><span class="line">host    <span class="keyword">replication</span>     <span class="keyword">replica</span>         xx.xx.xx.xx/<span class="number">16</span>         md5</span><br></pre></td></tr></table></figure><p>按 <strong>Esc</strong>，输入 <strong>:wq</strong>，保存文件返回。</p><p>执行以下命令，打开 postgresql.conf 文件。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/pgsql/<span class="number">12</span>/data/postgresql.conf</span><br></pre></td></tr></table></figure><p>按 <strong>i</strong> 进入编辑模式，分别找到以下参数，并将参数修改为以下内容：</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses = <span class="string">&#x27;*&#x27;</span>   #监听的内网 IP 地址</span><br><span class="line">max_connections = <span class="number">100</span>    #最大连接数，从库的 max_connections 必须要大于主库的</span><br><span class="line">wal_level = hot_standby  #启用热备模式</span><br><span class="line">synchronous_commit = <span class="keyword">on</span>  #开启同步复制</span><br><span class="line">max_wal_senders = <span class="number">32</span>     #同步最大的进程数量</span><br><span class="line">wal_sender_timeout = <span class="number">60</span>s #流复制主机发送数据的超时时间</span><br></pre></td></tr></table></figure><p>按 <strong>Esc</strong>，输入 <strong>:wq</strong>，保存文件返回。</p><p>执行以下命令，重启服务。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">restart</span> postgresql<span class="number">-12.</span>service</span><br></pre></td></tr></table></figure><h3 id="2、配置从节点"><a href="#2、配置从节点" class="headerlink" title="2、配置从节点"></a>2、配置从节点</h3><p>登录从节点实例。</p><p>执行以下命令，升级所有包、系统版本和内核。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">update</span> -y</span><br></pre></td></tr></table></figure><p>依次执行以下命令，安装 PostgreSQL。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="comment">--no-check-certificate https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm﻿</span></span><br><span class="line">rpm -ivh pgdg-redhat-repo-latest.noarch.rpm</span><br><span class="line">yum install postgresql12-<span class="keyword">server</span> postgresql12-contrib -y</span><br></pre></td></tr></table></figure><p>执行以下命令，使用 pg_basebackup 基础备份工具制定备份目录。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_basebackup -D /var/lib/pgsql/<span class="number">12</span>/data -h &lt;主节点公网 IP&gt; -p <span class="number">5432</span> -U <span class="keyword">replica</span> -X stream -P</span><br></pre></td></tr></table></figure><p>根据提示，输入数据库账号对应的密码，按 Enter。返回如下结果，表示备份成功。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Password</span>: </span><br><span class="line"><span class="number">24526</span>/<span class="number">24526</span> kB (<span class="number">100</span>%), <span class="number">1</span>/<span class="number">1</span> <span class="keyword">tablespace</span></span><br></pre></td></tr></table></figure><p>执行以下命令，拷贝 master 配置相关文件。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/pgsql<span class="number">-12</span>/<span class="keyword">share</span>/recovery.conf.sample /var/lib/pgsql/<span class="number">12</span>/data/recovery.conf</span><br></pre></td></tr></table></figure><p>执行以下命令，打开 recovery.conf 文件。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/pgsql/<span class="number">12</span>/data/recovery.conf</span><br></pre></td></tr></table></figure><p>按 <strong>i</strong> 切换至编辑模式，分别找到如下参数，并修改为如下内容：</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">standby_mode = <span class="keyword">on</span>     #声明此节点为从库</span><br><span class="line">primary_conninfo = <span class="string">&#x27;host=&lt;主节点公网 IP&gt; port=5432 user=数据库账号 password=数据库密码&#x27;</span> #对应主库的连接信息</span><br><span class="line">recovery_target_timeline = <span class="string">&#x27;latest&#x27;</span> #流复制同步到最新的数据</span><br></pre></td></tr></table></figure><p>按 <strong>Esc</strong>，输入 <strong>:wq</strong>，保存文件返回。</p><p>执行以下命令，打开 postgresql.conf 文件。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/pgsql/<span class="number">12</span>/data/postgresql.conf</span><br></pre></td></tr></table></figure><p>按 <strong>i</strong> 切换至编辑模式，分别找到如下参数，并修改为如下内容：﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max_connections = <span class="number">1000</span>             # 最大连接数，从库的 max_connections 必须要大于主库的</span><br><span class="line">hot_standby = <span class="keyword">on</span>                   # 开启热备</span><br><span class="line">max_standby_streaming_delay = <span class="number">30</span>s  # 数据流备份的最大延迟时间</span><br><span class="line">wal_receiver_status_interval = <span class="number">1</span>s  # 从节点向主节点报告自身状态的最长间隔时间</span><br><span class="line">hot_standby_feedback = <span class="keyword">on</span>          # 如果有错误的数据复制向主进行反馈</span><br></pre></td></tr></table></figure><p>按 <strong>Esc</strong>，输入 <strong>:wq</strong>，保存文件返回。</p><p>执行以下命令，修改数据目录的属组和属主。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R postgres.postgres /var/lib/pgsql/<span class="number">12</span>/data</span><br></pre></td></tr></table></figure><p>执行以下命令，启动服务。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">start</span> postgresql<span class="number">-12.</span>service</span><br></pre></td></tr></table></figure><p>执行以下命令，设置服务开机自启动。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">enable</span> postgresql<span class="number">-12.</span>service</span><br></pre></td></tr></table></figure><h3 id="3、验证部署"><a href="#3、验证部署" class="headerlink" title="3、验证部署"></a>3、验证部署</h3><p>执行以下命令，从节点备份目录。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_basebackup -D /var/lib/pgsql/<span class="number">12</span>/data -h &lt;主节点公网 IP&gt; -p <span class="number">5432</span> -U <span class="keyword">replica</span> -X stream -P</span><br></pre></td></tr></table></figure><p>﻿输入数据库密码并按 <strong>Enter</strong>，返回如下结果，则表示已备份成功。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Password</span>: <span class="number">24526</span>/<span class="number">24526</span> kB (<span class="number">100</span>%), <span class="number">1</span>/<span class="number">1</span> <span class="keyword">tablespace</span></span><br></pre></td></tr></table></figure><p>在主节点中，执行以下命令，查看 sender 进程。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux |grep sender</span><br></pre></td></tr></table></figure><p>﻿在从节点中，执行以下命令，查看 receiver 进程。﻿</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux |grep receiver</span><br></pre></td></tr></table></figure><p>返回如下结果，即表示可成功查看到 receiver 进程。</p><p>在主节点中，依次执行以下命令，进入 PostgreSQL 交互终端，在主库中查看从库状态。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su - postgres</span><br><span class="line">psql</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pg_stat_replication;</span><br></pre></td></tr></table></figure><p>﻿返回如下结果，即表示可成功查看到从库状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用CVM搭建-PostgreSQL-主从架构&quot;&gt;&lt;a href=&quot;#使用CVM搭建-PostgreSQL-主从架构&quot; class=&quot;headerlink&quot; title=&quot;使用CVM搭建 PostgreSQL 主从架构&quot;&gt;&lt;/a&gt;使用CVM搭建 PostgreSQ</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://wuchu.site/categories/PostgreSQL/"/>
    
    
    <category term="主从架构" scheme="https://wuchu.site/tags/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL系统表</title>
    <link href="https://wuchu.site/2024/10/29/pg-admin-tables/"/>
    <id>https://wuchu.site/2024/10/29/pg-admin-tables/</id>
    <published>2024-10-29T11:05:11.000Z</published>
    <updated>2024-10-29T11:38:05.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>系统表（System Tables）是 PostgreSQL 中的一组特殊表，用于存储和管理数据库的元数据和系统信息。这些系统表位于 “pg_catalog” 模式下，包含了关于数据库对象（如表、列、索引、约束等）以及其他系统级别信息的元数据。系统表存储了数据库的结构、统计信息、权限、查询计划等重要数据，支持数据库的正常运行和管理。通过查询系统表，您可以获取关于数据库的详细信息，进行数据库管理、性能优化和监控等操作。系统表提供了对数据库对象和系统状态的访问和查询接口，使用户能够了解和操作数据库的内部结构和属性。一些常见的 PostgreSQL 系统表包括 pg_class、pg_attribute、pg_namespace、pg_index、pg_constraint、pg_stat_user_tables 等。这些系统表存储了数据库的表、列、命名空间、索引、约束和统计信息等。</p></blockquote><p>需要注意的是，系统表通常由数据库管理员或具有足够权限的用户访问。对系统表的修改和查询需要谨慎操作，以避免对数据库的破坏或不可逆的更改。</p><h3 id="1、连接postgresql"><a href="#1、连接postgresql" class="headerlink" title="1、连接postgresql"></a>1、连接postgresql</h3><p>打开终端或命令提示符：打开终端（Linux&#x2F;macOS）或命令提示符（Windows）来执行命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - postgres</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql</span><br></pre></td></tr></table></figure><h3 id="2、列出系统表"><a href="#2、列出系统表" class="headerlink" title="2、列出系统表"></a>2、列出系统表</h3><p>连接到数据库后，执行以下 SQL 查询来列出可用的系统</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table_name <span class="keyword">FROM</span> information_schema.tables <span class="keyword">WHERE</span> table_schema <span class="operator">=</span> <span class="string">&#x27;pg_catalog&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="3、核心系统表的功能"><a href="#3、核心系统表的功能" class="headerlink" title="3、核心系统表的功能"></a>3、核心系统表的功能</h3><ol><li>pg_class：<br> 功能：存储数据库中的所有表和视图的元数据信息。<br> 字段：relname（表名）、relnamespace（所属命名空间）、reltype（关联类型）等。</li><li>pg_attribute：<br> 功能：包含表和视图的列信息，如列名、数据类型、约束等。<br> 字段：attname（列名）、attrelid（所属表ID）、atttypid（数据类型ID）等。</li><li>pg_namespace：<br> 功能：用于存储数据库中的命名空间（schemas）信息。<br> 字段：nspname（命名空间名称）、nspowner（所有者ID）等。</li><li>pg_index：<br>功能：存储表的索引信息，包括索引名称、索引类型、索引所属的表等。<br>字段：indexrelname（索引名称）、indrelid（所属表ID）、indkey（索引列的顺序）等。</li><li>pg_constraint：<br>功能：用于存储表的约束信息，如主键约束、外键约束等。<br>字段：conname（约束名称）、conrelid（所属表ID）、contype（约束类型）等。</li><li>pg_statistic：<br>功能：存储表的统计信息，用于查询优化。<br>字段：starelid（表ID）、stanumbers（列的统计信息）等。</li><li>pg_type：<br>功能：记录数据库中定义的数据类型信息。<br>字段：typname（类型名称）、typlen（类型长度）、typarray（数组类型ID）等。</li><li>pg_roles：<br>功能：存储数据库角色（用户、组）的信息。<br>字段：rolname（角色名称）、rolsuper（超级用户标志）、rolmembership（成员关系）等。</li><li>pg_database：<br>功能：包含数据库的元数据信息。<br>字段：datname（数据库名称）、datowner（所有者ID）、datcollate（默认排序规则）等。</li><li>pg_views：<br>功能：存储数据库中定义的视图的信息。<br>字段：viewname（视图名称）、viewdefinition（视图定义）等。</li><li>pg_trigger：<br>功能：存储触发器的信息。<br>字段：tgname（触发器名称）、tgrelid（所属表ID）、tgtype（触发事件类型）等。</li><li>pg_language：<br>功能：记录数据库中支持的编程语言的信息。<br>字段：lanname（语言名称）、lanowner（所有者ID）、lanpltrusted（可信标志）等。</li><li>pg_operator：<br>功能：存储数据库中定义的操作符的信息。<br>字段：oprname（操作符名称）、oprleft（左操作数类型ID）、oprright（右操作数类型ID）等。</li><li>pg_enum：<br>功能：用于存储枚举类型的信息。<br>字段：enumtypid（枚举类型ID）、enumlabel（枚举标签值）等。</li><li>pg_conversion：<br>功能：记录字符集转换的规则。<br>字段：conname（转换名称）、connamespace（所属命名空间）、conproc（转换函数ID）等。</li><li>pg_stat_user_tables：<br>功能：包含用户表的统计信息，如行数、更新次数、删除次数等。<br>字段：relid（表ID）、schemaname（模式名称）、relname（表名）等。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;系统表（System Tables）是 PostgreSQL 中的一组特殊表，用于存储和管理数据库的元数据和系统信</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://wuchu.site/categories/PostgreSQL/"/>
    
    
    <category term="PG系统表" scheme="https://wuchu.site/tags/PG%E7%B3%BB%E7%BB%9F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL参数</title>
    <link href="https://wuchu.site/2024/10/29/pg_params/"/>
    <id>https://wuchu.site/2024/10/29/pg_params/</id>
    <published>2024-10-29T11:05:11.000Z</published>
    <updated>2024-10-29T11:29:50.204Z</updated>
    
    <content type="html"><![CDATA[<ol><li>timescaledb.max_open_chunks_per_insert: 控制每个插入操作中允许打开的最大块数。</li><li>timescaledb.passfile: 指定用于连接到数据库的密码文件的路径。</li><li>timescaledb.remote_data_fetcher: 控制是否启用远程数据获取功能。</li><li>timescaledb.restoring: 控制是否处于恢复状态。</li><li>timescaledb.ssl_dir: 指定SSL证书和密钥文件的目录。</li><li>timescaledb_telemetry.cloud: 控制是否将遥测数据发送到云端。</li><li>timescaledb.telemetry_level: 控制遥测数据的详细程度。</li><li>cos_fdw.enable_https: 控制是否启用HTTPS协议。</li><li>pgaudit.log_mode: 控制审计日志记录的模式。</li><li>enable_async_append: 控制是否启用异步追加功能。</li><li>archive_timeout: 控制归档命令超时时间。</li><li>array_nulls: 控制数组中的空值处理方式。</li><li>audit_file_buffer_size: 指定审计日志文件缓冲区大小。</li><li>audit_file_flush_timeout: 指定审计日志文件刷新超时时间。</li><li>audit_log_directory: 指定审计日志文件存储目录。</li><li>audit_log_filename: 指定审计日志文件名。</li><li>audit_log_rotation_age: 控制审计日志按时间轮转的周期。</li><li>audit_log_rotation_size: 控制审计日志按大小轮转的阈值。</li><li>audit_log_truncate_on_rotation: 控制审计日志轮转时是否截断文件。</li><li>authentication_timeout: 控制认证超时时间。</li><li>auto_explain.log_analyze: 控制是否记录自动解释的分析结果。</li><li>auto_explain.log_buffers: 控制是否记录自动解释的缓冲区信息。</li><li>auto_explain.log_format: 控制自动解释日志的格式。</li><li>auto_explain.log_level: 控制自动解释日志的详细程度。</li><li>auto_explain.log_min_duration: 控制记录自动解释的最小执行时间。</li><li>auto_explain.log_nested_statements: 控制是否记录自动解释的嵌套语句。</li><li>auto_explain.log_settings: 控制是否记录自动解释的配置信息。</li><li>auto_explain.log_timing: 控制是否记录自动解释的时间信息。</li><li>auto_explain.log_triggers: 控制是否记录自动解释的触发器信息。</li><li>auto_explain.log_verbose: 控制是否记录自动解释的详细信息。</li><li>auto_explain.log_wal: 控制是否记录自动解释的WAL信息。</li><li>auto_explain.sample_rate: 控制自动解释的采样率。</li><li>bytea_output: 控制bytea数据类型的输出格式。</li><li>autovacuum_analyze_scale_factor: 控制自动分析的比例因子。</li><li>autovacuum_analyze_threshold: 控制自动分析的阈值。</li><li>autovacuum_freeze_max_age: 控制自动冻结的最大年龄。</li><li>autovacuum_max_workers: 控制自动清理的最大工作进程数。</li><li>autovacuum_multixact_freeze_max_age: 控制自动多事务冻结的最大年龄。</li><li>autovacuum_naptime: 控制自动清理的休眠时间。</li><li>autovacuum_vacuum_cost_delay: 控制自动清理的成本延迟。</li><li>autovacuum_vacuum_cost_limit: 控制自动清理的成本限制。</li><li>autovacuum_vacuum_insert_scale_factor: 控制自动清理插入比例因子。</li><li>autovacuum_vacuum_insert_threshold: 控制自动清理插入阈值。</li><li>autovacuum_vacuum_scale_factor: 控制自动清理比例因子。</li><li>autovacuum_vacuum_threshold: 控制自动清理阈值。</li><li>autovacuum_work_mem: 控制自动清理的工作内存。</li><li>backend_flush_after: 控制后端进程刷新数据的延迟时间。</li><li>backslash_quote: 控制反斜杠引用的处理方式。</li><li>backtrace_functions: 控制是否记录函数调用堆栈信息。</li><li>basebackup_exclude_paths: 指定基本备份时要排除的路径。</li><li>bgwriter_delay: 控制后台写入进程的延迟时间。</li><li>bgwriter_flush_after: 控制后台写入进程刷新数据的延迟时间。</li><li>bgwriter_lru_maxpages: 控制后台写入进程LRU缓存的最大页数。</li><li>bgwriter_lru_multiplier: 控制后台写入进程LRU缓存的乘数。</li><li>check_function_bodies: 控制是否检查函数体。</li><li>checkpoint_completion_target: 控制检查点完成目标。</li><li>checkpoint_flush_after: 控制检查点刷新数据的延迟时间。</li><li>checkpoint_timeout: 控制检查点超时时间。</li><li>checkpoint_warning: 控制检查点警告阈值。</li><li>client_connection_check_interval: 控制客户端连接检查间隔。</li><li>client_encoding: 控制客户端编码。</li><li>client_min_messages: 控制客户端最小消息级别。</li><li>commit_delay: 控制提交延迟时间。</li><li>commit_siblings: 控制提交同级数。</li><li>compute_query_id: 控制是否计算查询ID。</li><li>constraint_exclusion: 控制约束排除策略。</li><li>cpu_index_tuple_cost: 控制CPU索引元组成本。</li><li>cpu_operator_cost: 控制CPU操作成本。</li><li>cpu_tuple_cost: 控制CPU元组成本。</li><li>createrole_self_grant: 控制是否允许自我授予角色。</li><li>cron.database_name: 指定Cron作业的数据库名称。</li><li>cron.enable_superuser_jobs: 控制是否允许超级用户运行Cron作业。</li><li>cron.log_min_messages: 控制Cron作业的最小消息级别。</li><li>cron.log_run: 控制是否记录Cron作业运行信息。</li><li>cron.log_statement: 控制是否记录Cron作业语句信息。</li><li>cron.max_running_jobs: 控制最大运行Cron作业数。</li><li>cron.use_background_workers: 控制是否使用后台工作进程运行Cron作业。</li><li>cursor_tuple_fraction: 控制游标元组分数。</li><li>datestyle: 控制日期样式。</li><li>db_user_namespace: 控制数据库用户命名空间。</li><li>deadlock_timeout: 控制死锁超时时间。</li><li>debug_io_direct: 控制是否启用IO直接调试。</li><li>debug_logical_replication_streaming: 控制逻辑复制流调试。</li><li>debug_parallel_query: 控制并行查询调试。</li><li>debug_pretty_print: 控制是否启用漂亮打印调试。</li><li>debug_print_parse: 控制是否打印解析调试。</li><li>debug_print_plan: 控制是否打印计划调试。</li><li>debug_print_rewritten: 控制是否打印重写调试。</li><li>default_statistics_target: 控制默认统计目标。</li><li>default_table_access_method: 控制默认表访问方法。</li><li>default_toast_compression: 控制默认TOAST压缩。</li><li>default_transaction_deferrable: 控制默认事务是否可延迟。</li><li>enable_sort: 控制是否启用排序。</li><li>default_transaction_isolation: 控制默认事务隔离级别。</li><li>disable_dblink_connect_to_other: 控制是否禁用DBLink连接到其他数据库。</li><li>effective_cache_size: 控制有效缓存大小。</li><li>effective_io_concurrency: 控制有效IO并发性。</li><li>enable_bitmapscan: 控制是否启用位图扫描。</li><li>enable_gathermerge: 控制是否启用聚合合并。</li><li>enable_hashagg: 控制是否启用哈希聚合。</li><li>enable_hashjoin: 控制是否启用哈希连接。</li><li>enable_incremental_sort: 控制是否启用增量排序。</li><li>enable_indexonlyscan: 控制是否启用仅索引扫描。</li><li>enable_indexscan: 控制是否启用索引扫描。</li><li>enable_material: 控制是否启用材料化。</li><li>enable_memoize: 控制是否启用记忆化。</li><li>enable_mergejoin: 控制是否启用合并连接。</li><li>enable_nestloop: 控制是否启用嵌套循环。</li><li>enable_parallel_append: 控制是否启用并行追加。</li><li>enable_parallel_hash: 控制是否启用并行哈希。</li><li>enable_partition_pruning: 控制是否启用分区修剪。</li><li>enable_partitionwise_aggregate: 控制是否启用分区聚合。</li><li>enable_partitionwise_join: 控制是否启用分区连接。</li><li>enable_presorted_aggregate: 控制是否启用预排序聚合。</li><li>enable_seqscan: 控制是否启用顺序扫描。</li><li>enable_superuser_call_all_event_triggers: 控制超级用户是否调用所有事件触发器。</li><li>enable_superuser_call_all_functions: 控制超级用户是否调用所有函数。</li><li>enable_tidscan: 控制是否启用TID扫描。</li><li>escape_string_warning: 控制是否警告转义字符串。</li><li>exit_on_error: 控制是否在错误时退出。</li><li>extension_blacklist: 控制扩展黑名单。</li><li>extra_float_digits: 控制额外浮点数位数。</li><li>failover_slot_timeline_diverged_option: 控制故障转移时时间线分歧选项。</li><li>from_collapse_limit: 控制FROM合并限制。</li><li>geqo: 控制是否启用遗传查询优化。</li><li>geqo_effort: 控制遗传查询优化的努力程度。</li><li>geqo_generations: 控制遗传查询优化的代数。</li><li>geqo_pool_size: 控制遗传查询优化的池大小。</li><li>geqo_seed: 控制遗传查询优化的种子。</li><li>geqo_selection_bias: 控制遗传查询优化的选择偏差。</li><li>geqo_threshold: 控制遗传查询优化的阈值。</li><li>gin_fuzzy_search_limit: 控制GIN模糊搜索限制。</li><li>jit_expressions: 控制JIT表达式。</li><li>gin_pending_list_limit: 控制GIN挂起列表限制。</li><li>gss_accept_delegation: 控制GSS接受委托。</li><li>hash_mem_multiplier: 控制哈希内存乘数。</li><li>hot_standby_feedback: 控制热备份反馈。</li><li>huge_pages: 控制是否使用大页。</li><li>huge_page_size: 控制大页大小。</li><li>tencentdb_pwdcheck.min_digit_number: 控制密码检查的最小数字数。</li><li>icu_validation_level: 控制ICU验证级别。</li><li>idle_in_transaction_session_timeout: 控制事务空闲超时时间。</li><li>idle_session_timeout: 控制空闲会话超时时间。</li><li>ignore_invalid_pages: 控制是否忽略无效页面。</li><li>ignore_system_indexes: 控制是否忽略系统索引。</li><li>IntervalStyle: 控制间隔样式。</li><li>jit: 控制是否启用JIT编译。</li><li>jit_above_cost: 控制JIT编译的成本阈值。</li><li>jit_debugging_support: 控制JIT调试支持。</li><li>jit_dump_bitcode: 控制是否转储JIT位码。</li><li>jit_inline_above_cost: 控制JIT内联成本阈值。</li><li>jit_optimize_above_cost: 控制JIT优化成本阈值。</li><li>jit_profiling_support: 控制JIT性能分析支持。</li><li>jit_provider: 控制JIT提供者。</li><li>jit_tuple_deforming: 控制JIT元组解析。</li><li>join_collapse_limit: 控制连接合并限制。</li><li>tencentdb_pwdcheck.min_length: 控制密码检查的最小长度。</li><li>lc_monetary: 控制货币本地化。</li><li>lc_numeric: 控制数字本地化。</li><li>lc_time: 控制时间本地化。</li><li>lock_timeout: 控制锁超时时间。</li><li>log_autovacuum_min_duration: 控制自动清理最小日志记录时间。</li><li>log_checkpoints: 控制检查点日志记录。</li><li>log_connections: 控制连接日志记录。</li><li>log_disconnections: 控制断开连接日志记录。</li><li>log_duration: 控制持续时间日志记录。</li><li>log_error_verbosity: 控制错误详细程度。</li><li>log_executor_stats: 控制执行器统计日志记录。</li><li>log_filename: 指定日志文件名。</li><li>tencentdb_pwdcheck.min_lowercase_number: 控制密码检查的最小小写字母数。</li><li>logical_decoding_work_mem: 控制逻辑解码工作内存。</li><li>log_line_prefix: 控制日志行前缀。</li><li>log_lock_waits: 控制锁等待日志记录。</li><li>log_min_duration_sample: 控制最小持续时间采样。</li><li>log_min_duration_statement: 控制最小持续时间语句。</li><li>log_min_error_statement: 控制最小错误语句级别。</li><li>log_min_messages: 控制最小消息级别。</li><li>log_parameter_max_length: 控制参数最大长度。</li><li>log_parameter_max_length_on_error: 控制错误时参数最大长度。</li><li>log_parser_stats: 控制解析器统计日志记录。</li><li>log_planner_stats: 控制计划统计日志记录。</li><li>log_recovery_conflict_waits: 控制恢复冲突等待日志记录。</li><li>log_replication_commands: 控制复制命令日志记录。</li><li>log_rotation_age: 控制日志轮转周期。</li><li>log_rotation_size: 控制日志轮转大小。</li><li>log_startup_progress_interval: 控制启动进度日志记录间隔。</li><li>log_statement: 控制语句日志记录。</li><li>log_statement_sample_rate: 控制语句采样率。</li><li>log_statement_stats: 控制语句统计日志记录。</li><li>log_temp_files: 控制临时文件日志记录。</li><li>log_timezone: 控制日志时区。</li><li>log_transaction_sample_rate: 控制事务采样率。</li><li>log_truncate_on_rotation: 控制轮转时是否截断日志。</li><li>maintenance_io_concurrency: 控制维护IO并发性。</li><li>maintenance_work_mem: 控制维护工作内存。</li><li>max_connections: 控制最大连接数。</li><li>max_locks_per_transaction: 控制每个事务的最大锁数。</li><li>max_logical_replication_workers: 控制最大逻辑复制工作进程数。</li><li>max_parallel_apply_workers_per_subscription: 控制每个订阅的最大并行应用工作进程数。</li><li>max_parallel_maintenance_workers: 控制最大并行维护工作进程数。</li><li>max_parallel_workers: 控制最大并行工作进程数。</li><li>search_path: 控制搜索路径。</li><li>max_parallel_workers_per_gather: 控制每个聚集操作的最大并行工作进程数。</li><li>max_pred_locks_per_page: 控制每页的最大预测锁数。</li><li>max_pred_locks_per_relation: 控制每个关系的最大预测锁数。</li><li>max_pred_locks_per_transaction: 控制每个事务的最大预测锁数。</li><li>max_prepared_transactions: 控制最大准备事务数。</li><li>max_replication_slots: 控制最大复制槽数。</li><li>pgaudit.log_level: 控制审计日志级别。</li><li>max_slot_wal_keep_size: 控制最大槽保留WAL大小。</li><li>max_stack_depth: 控制最大堆栈深度。</li><li>max_standby_archive_delay: 控制最大备用归档延迟。</li><li>max_standby_streaming_delay: 控制最大备用流延迟。</li><li>max_sync_workers_per_subscription: 控制每个订阅的最大同步工作进程数。</li><li>max_wal_senders: 控制最大WAL发送者数。</li><li>max_wal_size: 控制最大WAL大小。</li><li>max_worker_processes: 控制最大工作进程数。</li><li>min_dynamic_shared_memory: 控制最小动态共享内存。</li><li>min_parallel_index_scan_size: 控制最小并行索引扫描大小。</li><li>min_parallel_table_scan_size: 控制最小并行表扫描大小。</li><li>min_wal_size: 控制最小WAL大小。</li><li>old_snapshot_threshold: 控制旧快照阈值。</li><li>parallel_leader_participation: 控制并行领导者参与。</li><li>parallel_setup_cost: 设置并行查询的启动成本，即启动并行查询所需的额外成本。</li><li>parallel_tuple_cost: 设置并行查询的元组成本，即并行查询每处理一个元组所需的额外成本。</li><li>password_encryption: 控制密码的加密方式。</li><li>pgaudit.hide_password: 控制是否隐藏密码信息。</li><li>pgaudit.log: 控制是否记录审计日志。</li><li>pgaudit.log_catalog: 控制是否记录审计日志中的目录操作。</li><li>pgaudit.log_client: 控制是否记录审计日志中的客户端信息。</li><li>pgaudit.log_error_statement: 控制是否记录审计日志中的错误语句。</li><li>pgaudit.log_parameter: 控制是否记录审计日志中的参数信息。</li><li>pgaudit.log_relation: 控制是否记录审计日志中的关系信息。</li><li>pgaudit.log_rows: 控制是否记录审计日志中的行信息。</li><li>pgaudit.log_statement: 控制是否记录审计日志中的语句信息。</li><li>pgaudit.log_statement_once: 控制是否只记录一次相同的语句信息。</li><li>pgaudit.role: 设置审计日志的角色。</li><li>pg_stat_statements.max: 设置pg_stat_statements插件中最多保存的查询数量。</li><li>pg_stat_statements.save: 设置pg_stat_statements插件是否保存查询计划。</li><li>pg_stat_statements.track: 设置pg_stat_statements插件是否跟踪查询。</li><li>pg_stat_statements.track_planning: 设置pg_stat_statements插件是否跟踪查询计划。</li><li>pg_stat_statements.track_utility: 设置pg_stat_statements插件是否跟踪utility命令。</li><li>plan_cache_mode: 设置计划缓存模式。</li><li>post_auth_delay: 设置认证后延迟时间。</li><li>send_abort_for_crash: 控制是否在崩溃时发送中止信号。</li><li>pre_auth_delay: 设置认证前延迟时间。</li><li>quote_all_identifiers: 控制是否引用所有标识符。</li><li>random_page_cost: 设置随机访问磁盘页的成本。</li><li>rds_server_handler.fdw_whitelist: 设置RDS服务器处理程序的FDW白名单。</li><li>rds_server_handler.shark_api_url: 设置RDS服务器处理程序的shark API URL。</li><li>recovery_init_sync_method: 设置恢复初始同步方法。</li><li>recovery_prefetch: 设置恢复预取大小。</li><li>recursive_worktable_factor: 设置递归工作表因子。</li><li>remove_temp_files_after_crash: 控制是否在崩溃后删除临时文件。</li><li>reserved_connections: 设置保留连接数。</li><li>row_security: 控制行级安全。</li><li>scram_iterations: 设置SCRAM迭代次数。</li><li>send_abort_for_kill: 控制是否在kill时发送中止信号。</li><li>seq_page_cost: 设置顺序访问磁盘页的成本。</li><li>session_replication_role: 设置会话复制角色。</li><li>soft_limit_connections: 设置软连接限制。</li><li>squeeze.max_xlock_time: 设置最大X锁时间。</li><li>squeeze.worker_autostart: 控制是否自动启动压缩工作线程。</li><li>squeeze.worker_role: 设置压缩工作线程角色。</li><li>tencentdb_az_five: 设置腾讯云数据库的五个可用区。</li><li>standard_conforming_strings: 控制是否符合标准的字符串处理。</li><li>statement_timeout: 设置语句超时时间。</li><li>stats_fetch_consistency: 设置统计数据获取一致性。</li><li>synchronize_seqscans: 控制是否同步顺序扫描。</li><li>synchronous_commit: 设置同步提交方式。</li><li>tcp_keepalives_count: 设置TCP保活计数。</li><li>tcp_keepalives_idle: 设置TCP保活空闲时间。</li><li>tcp_keepalives_interval: 设置TCP保活间隔时间。</li><li>tcp_user_timeout: 设置TCP用户超时时间。</li><li>temp_buffers: 设置临时缓冲区大小。</li><li>tencentdb_audit_message_truncate_length: 设置腾讯云数据库审计消息截断长度。</li><li>timescaledb.max_cached_chunks_per_hypertable: 设置每个超表的最大缓存块数。</li><li>tencentdb_creating_extension_as_superuser: 控制是否以超级用户身份创建扩展。</li><li>tencentdb_enable_copy_program: 控制是否启用复制程序。</li><li>tencentdb_enable_creating_extension_do_copy: 控制是否启用创建扩展时进行复制。</li><li>tencentdb_enable_do_copy: 控制是否启用DO COPY。</li><li>tencentdb_enable_superuser_unsafe_behaviour: 控制是否启用超级用户不安全行为。</li><li>tencentdb_enable_trusted_extension: 控制是否启用受信任的扩展。</li><li>tencentdb_pwdcheck.delay_milliseconds: 设置密码检查延迟时间。</li><li>tencentdb_pwdcheck.enable_tencentdb_pwdcheck: 控制是否启用腾讯云数据库密码检查。</li><li>tencentdb_pwdcheck.max_length: 设置密码检查的最大长度。</li><li>tencentdb_pwdcheck.min_special_character_number: 设置密码检查的最小特殊字符数。</li><li>tencentdb_pwdcheck.min_uppercase_number: 设置密码检查的最小大写字母数。</li><li>tencentdb_system_stat.sampling_interval: 设置腾讯云数据库系统统计采样间隔。</li><li>timescaledb.disable_load: 控制是否禁用加载。</li><li>timescaledb.enable_2pc: 控制是否启用两阶段提交。</li><li>timescaledb.enable_async_append: 控制是否启用异步追加。</li><li>timescaledb.enable_cagg_reorder_groupby: 控制是否启用Cagg重新排序groupby。</li><li>timescaledb.enable_chunk_append: 控制是否启用块追加。</li><li>timescaledb.enable_client_ddl_on_data_nodes: 控制是否在数据节点上启用客户端DDL。</li><li>timescaledb.enable_connection_binary_data: 控制是否启用连接二进制数据。</li><li>timescaledb.enable_constraint_aware_append: 控制是否启用约束感知追加。</li><li>timescaledb.enable_constraint_exclusion: 控制是否启用约束排除。</li><li>timescaledb.enable_optimizations: 控制是否启用优化。</li><li>timescaledb.enable_ordered_append: 控制是否启用有序追加。</li><li>timescaledb.enable_parallel_chunk_append: 控制是否启用并行块追加。</li><li>timescaledb.enable_per_data_node_queries: 控制是否启用每个数据节点的查询。</li><li>timescaledb.enable_qual_propagation: 控制是否启用质量传播。</li><li>timescaledb.enable_remote_explain: 控制是否启用远程解释。</li><li>timescaledb.enable_runtime_exclusion: 控制是否启用运行时排除。</li><li>timescaledb.enable_skipscan: 控制是否启用跳过扫描。</li><li>timescaledb.enable_transparent_decompression: 控制是否启用透明解压缩。</li><li>timescaledb.last_tuned: 最后调整的时间。</li><li>timescaledb.last_tuned_version: 最后调整的版本。</li><li>timescaledb.license: TimescaleDB的许可证。</li><li>timescaledb.max_background_workers: 设置最大后台工作线程数。</li><li>timezone: 设置时区。</li><li>timezone_abbreviations: 设置时区缩写。</li><li>topn.number_of_counters: 设置TopN计数器数量。</li><li>trace_notify: 控制是否跟踪通知。</li><li>trace_sort: 控制是否跟踪排序。</li><li>track_activities: 控制是否跟踪活动。</li><li>track_activity_query_size: 设置跟踪活动查询大小。</li><li>track_commit_timestamp: 控制是否跟踪提交时间戳。</li><li>track_functions: 控制是否跟踪函数。</li><li>track_io_timing: 控制是否跟踪IO时间。</li><li>track_wal_io_timing: 控制是否跟踪WAL IO时间。</li><li>transaction_deferrable: 设置事务是否可延迟。</li><li>transaction_read_only: 设置事务是否只读。</li><li>transform_null_equals: 控制是否将NULL转换为等号。</li><li>vacuum_buffer_usage_limit: 设置VACUUM缓冲区使用限制。</li><li>vacuum_cost_delay: 设置VACUUM成本延迟。</li><li>vacuum_cost_limit: 设置VACUUM成本限制。</li><li>vacuum_cost_page_dirty: 设置VACUUM脏页成本。</li><li>vacuum_cost_page_hit: 设置VACUUM命中页成本。</li><li>vacuum_cost_page_miss: 设置VACUUM未命中页成本。</li><li>vacuum_failsafe_age: 设置VACUUM失败安全年龄。</li><li>vacuum_freeze_min_age: 设置VACUUM冻结最小年龄。</li><li>vacuum_freeze_table_age: 设置VACUUM冻结表年龄。</li><li>vacuum_multixact_failsafe_age: 设置VACUUM多事务失败安全年龄。</li><li>vacuum_multixact_freeze_min_age: 设置VACUUM多事务冻结最小年龄。</li><li>vacuum_multixact_freeze_table_age: 设置VACUUM多事务冻结表年龄。</li><li>wal_buffers: 设置WAL缓冲区大小。</li><li>wal_decode_buffer_size: 设置WAL解码缓冲区大小。</li><li>wal_keep_size: 设置WAL保留大小。</li><li>wal_level: 设置WAL级别。</li><li>wal_log_hints: 控制是否记录WAL日志提示。</li><li>wal_receiver_create_temp_slot: 控制是否创建临时插槽。</li><li>wal_receiver_timeout: 设置WAL接收超时。</li><li>wal_sender_timeout: 设置WAL发送超时。</li><li>wal_skip_threshold: 设置WAL跳过阈值。</li><li>wal_writer_delay: 设置WAL写入延迟。</li><li>wal_writer_flush_after: 设置WAL写入后刷新。</li><li>work_mem: 设置工作内存大小。</li><li>xmlbinary: 设置XML二进制格式。</li><li>xmloption: 设置XML选项。</li><li>cos_fdw.internal_middle_url: 设置COS FDW内部中间URL。</li><li>cos_fdw.internal_domain_url: 设置COS FDW内部域URL。</li><li>shared_preload_libraries: 设置共享预加载库。</li><li>temp_file_limit: 设置临时文件限制。</li><li>cos_fdw.domain_url: 设置COS FDW域URL。</li><li>tencentdb_serverless.min_cpu_cores: 设置腾讯云数据库无服务器最小CPU核心数。</li><li>tencentdb_serverless.max_cpu_cores: 设置腾讯云数据库无服务器最大CPU核心数。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;timescaledb.max_open_chunks_per_insert: 控制每个插入操作中允许打开的最大块数。&lt;/li&gt;
&lt;li&gt;timescaledb.passfile: 指定用于连接到数据库的密码文件的路径。&lt;/li&gt;
&lt;li&gt;timescaledb</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://wuchu.site/categories/PostgreSQL/"/>
    
    
    <category term="PG参数" scheme="https://wuchu.site/tags/PG%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>XID用的太多怎么办</title>
    <link href="https://wuchu.site/2024/10/28/xid_deal/"/>
    <id>https://wuchu.site/2024/10/28/xid_deal/</id>
    <published>2024-10-28T15:54:40.000Z</published>
    <updated>2024-10-29T11:09:54.039Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-查看哪个库xid最小"><a href="#1-查看哪个库xid最小" class="headerlink" title="1.查看哪个库xid最小"></a>1.查看哪个库xid最小</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> datname,(<span class="number">2147483647</span><span class="operator">-</span>pg_catalog.age(datfrozenxid))::<span class="type">int</span> <span class="keyword">FROM</span> pg_database <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span>; </span><br></pre></td></tr></table></figure><h4 id="2-进入对应的库中，查看表年龄"><a href="#2-进入对应的库中，查看表年龄" class="headerlink" title="2.进入对应的库中，查看表年龄"></a>2.进入对应的库中，查看表年龄</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.oid::regclass <span class="keyword">as</span> table_name, pg_size_pretty(pg_relation_size(c.oid)), greatest(age(c.relfrozenxid),age(t.relfrozenxid)) <span class="keyword">as</span> age <span class="keyword">FROM</span> pg_class c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_class t <span class="keyword">ON</span> c.reltoastrelid <span class="operator">=</span> t.oid <span class="keyword">WHERE</span> c.relkind <span class="keyword">IN</span> (<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;m&#x27;</span>) <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h4 id="3-对小的表执行vacuum，如果全库都低，直接全库清理；"><a href="#3-对小的表执行vacuum，如果全库都低，直接全库清理；" class="headerlink" title="3.对小的表执行vacuum，如果全库都低，直接全库清理；"></a>3.对小的表执行vacuum，如果全库都低，直接全库清理；</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单表清理：vacuum verbose 表名;</span><br><span class="line">全库清理：vacuum verbose;</span><br></pre></td></tr></table></figure><h4 id="4-注意执行的时候新起一个会话，看看自己的vacuum有没有被autovacuum阻塞。如果有的话，可以干掉autovacuum"><a href="#4-注意执行的时候新起一个会话，看看自己的vacuum有没有被autovacuum阻塞。如果有的话，可以干掉autovacuum" class="headerlink" title="4.注意执行的时候新起一个会话，看看自己的vacuum有没有被autovacuum阻塞。如果有的话，可以干掉autovacuum"></a>4.注意执行的时候新起一个会话，看看自己的vacuum有没有被autovacuum阻塞。如果有的话，可以干掉autovacuum</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pid, state,wait_event,wait_event_type,usename, <span class="built_in">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> (now()<span class="operator">-</span>query_start)), substr(query, <span class="number">0</span>, <span class="number">150</span>) <span class="keyword">from</span> pg_stat_activity <span class="keyword">where</span> state <span class="operator">!=</span> <span class="string">&#x27;idle&#x27;</span> <span class="keyword">and</span> <span class="built_in">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> (now()<span class="operator">-</span>xact_start)) <span class="operator">&gt;</span> <span class="number">300</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_terminate_backend(<span class="number">33431</span>);</span><br></pre></td></tr></table></figure><blockquote><p>确保机器内存足够的情况下增大内存参数可以加速清理：set maintenance_work_mem &#x3D; ‘10GB’; </p></blockquote><p>xid降低的原因：</p><ul><li>1.业务xid消耗过快或者autovacuum速度慢，先手动清理。这种情况下通过调整实例autovacuum相关参数，加快实例清理。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">autovacuum_analyze_scale_factor</span><br><span class="line">autovacuum_analyze_threshold</span><br><span class="line">autovacuum_vacuum_scale_factor</span><br><span class="line">autovacuum_vacuum_threshold</span><br><span class="line">autovacuum_vacuum_cost_limit</span><br><span class="line">autovacuum_vacuum_cost_delay</span><br></pre></td></tr></table></figure><ul><li>2.slot残留，联系用户清理，紧急情况下，自行清理。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">处理方法：</span><br><span class="line">查询：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_replication_slots <span class="keyword">where</span> active<span class="operator">=</span><span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">清理：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_drop_replication_slot(【slots_name】);</span><br></pre></td></tr></table></figure><ul><li>3.长事务残留，联系用户清理，紧急情况下，自行清理。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pid, state,wait_event,wait_event_type,usename, <span class="built_in">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> (now()<span class="operator">-</span>query_start)), substr(query, <span class="number">0</span>, <span class="number">150</span>) <span class="keyword">from</span> pg_stat_activity <span class="keyword">where</span> state <span class="operator">!=</span> <span class="string">&#x27;idle&#x27;</span> <span class="keyword">and</span> <span class="built_in">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> (now()<span class="operator">-</span>xact_start)) <span class="operator">&gt;</span> <span class="number">300</span>;</span><br></pre></td></tr></table></figure><ul><li><p>4.autovacuum_freeze_max_age参数设置过大，导致没有触发autovacuum，联系用户处理</p></li><li><p>5.临时表所在的会话未断开，阻塞xid回收，联系用户杀掉长连接，或者重启实例</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看剩余的xid：</span><br><span class="line"><span class="keyword">SELECT</span> datname,(<span class="number">2147483647</span><span class="operator">-</span>pg_catalog.age(datfrozenxid))::<span class="type">int</span> <span class="keyword">FROM</span> pg_database <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">每个表的年龄排序：</span><br><span class="line"><span class="keyword">SELECT</span> c.oid::regclass <span class="keyword">as</span> table_name, pg_size_pretty(pg_relation_size(c.oid)), greatest(age(c.relfrozenxid),age(t.relfrozenxid)) <span class="keyword">as</span> age <span class="keyword">FROM</span> pg_class c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_class t <span class="keyword">ON</span> c.reltoastrelid <span class="operator">=</span> t.oid <span class="keyword">WHERE</span> c.relkind <span class="keyword">IN</span> (<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;m&#x27;</span>) <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="报错处理方法："><a href="#报错处理方法：" class="headerlink" title="报错处理方法："></a>报错处理方法：</h3><blockquote><p>ERROR:  found xmin 414915252 from before relfrozenxid 794253244</p></blockquote><p>该报错为PG老版本bug导致，需要清理一下relcache，有两种方法：</p><ul><li>1、重启数据库，重启后会重新读入新数据内容到relcache中，相当于刷新relcache。</li><li>2、移除对应数据目录中的pg_internal.init文件，数据库会自动生成一个新的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-查看哪个库xid最小&quot;&gt;&lt;a href=&quot;#1-查看哪个库xid最小&quot; class=&quot;headerlink&quot; title=&quot;1.查看哪个库xid最小&quot;&gt;&lt;/a&gt;1.查看哪个库xid最小&lt;/h4&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://wuchu.site/categories/PostgreSQL/"/>
    
    
    <category term="xid" scheme="https://wuchu.site/tags/xid/"/>
    
  </entry>
  
  <entry>
    <title>Redux的基本原理</title>
    <link href="https://wuchu.site/2024/08/13/redux/"/>
    <id>https://wuchu.site/2024/08/13/redux/</id>
    <published>2024-08-13T12:43:52.000Z</published>
    <updated>2024-10-29T11:54:02.782Z</updated>
    
    <content type="html"><![CDATA[<img src="/2024/08/13/redux/redux.gif" class="" title="图片引用方法一"><h3 id="求和案例-redux精简版"><a href="#求和案例-redux精简版" class="headerlink" title="求和案例_redux精简版"></a>求和案例_redux精简版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).去除<span class="title class_">Count</span>组件自身的状态</span><br><span class="line">(<span class="number">2</span>).<span class="property">src</span>下建立:</span><br><span class="line">    -redux</span><br><span class="line">        -store.<span class="property">js</span></span><br><span class="line">        -count_reducer.<span class="property">js</span></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>).<span class="property">store</span>.<span class="property">js</span>：</span><br><span class="line">    <span class="number">1</span>).引入redux中的createStore函数，创建一个store</span><br><span class="line">    <span class="number">2</span>).<span class="property">createStore</span>调用时要传入一个为其服务的reducer</span><br><span class="line">    <span class="number">3</span>).记得暴露store对象</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>).<span class="property">count_reducer</span>.<span class="property">js</span>：</span><br><span class="line">    <span class="number">1</span>).<span class="property">reducer</span>的本质是一个函数，接收：preState,action，返回加工后的状态</span><br><span class="line">    <span class="number">2</span>).<span class="property">reducer</span>有两个作用：初始化状态，加工状态</span><br><span class="line">    <span class="number">3</span>).<span class="property">reducer</span>被第一次调用时，是store自动触发的，</span><br><span class="line">                    传递的preState是<span class="literal">undefined</span>,</span><br><span class="line">                    传递的action是:&#123;<span class="attr">type</span>:<span class="string">&#x27;@@REDUX/INIT_a.2.b.4&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>).在index.<span class="property">js</span>中监测store中状态的改变，一旦发生改变重新渲染&lt;<span class="title class_">App</span>/&gt;</span><br><span class="line">    备注：redux只负责管理状态，至于状态的改变驱动着页面的展示，要靠我们自己写。</span><br></pre></td></tr></table></figure><h3 id="求和案例-redux完整版"><a href="#求和案例-redux完整版" class="headerlink" title="求和案例_redux完整版"></a>求和案例_redux完整版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新增文件：</span><br><span class="line"><span class="number">1.</span>count_action.<span class="property">js</span> 专门用于创建action对象</span><br><span class="line"><span class="number">2.</span>constant.<span class="property">js</span> 放置容易写错的type值</span><br></pre></td></tr></table></figure><h3 id="求和案例-redux异步action版"><a href="#求和案例-redux异步action版" class="headerlink" title="求和案例_redux异步action版"></a>求和案例_redux异步action版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).明确：延迟的动作不想交给组件自身，想交给<span class="title function_">action</span></span><br><span class="line">(<span class="number">2</span>).何时需要异步action：想要对状态进行操作，但是具体的数据靠异步任务返回。</span><br><span class="line">(<span class="number">3</span>).具体编码：</span><br><span class="line"><span class="number">1</span>).<span class="property">yarn</span> add redux-thunk，并配置在store中</span><br><span class="line"><span class="number">2</span>).创建action的函数不再返回一般对象，而是一个函数，该函数中写异步任务。</span><br><span class="line"><span class="number">3</span>).异步任务有结果后，分发一个同步的action去真正操作数据。</span><br><span class="line">(<span class="number">4</span>).备注：异步action不是必须要写的，完全可以自己等待异步任务的结果了再去分发同步action。</span><br></pre></td></tr></table></figure><h3 id="求和案例-react-redux基本使用"><a href="#求和案例-react-redux基本使用" class="headerlink" title="求和案例_react-redux基本使用"></a>求和案例_react-redux基本使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).明确两个概念：</span><br><span class="line">        <span class="number">1</span>).<span class="property">UI</span>组件:不能使用任何redux的api，只负责页面的呈现、交互等。</span><br><span class="line">        <span class="number">2</span>).容器组件：负责和redux通信，将结果交给<span class="variable constant_">UI</span>组件。</span><br><span class="line">(<span class="number">2</span>).如何创建一个容器组件————靠react-redux 的 connect函数</span><br><span class="line">        <span class="title function_">connect</span>(mapStateToProps,mapDispatchToProps)(<span class="variable constant_">UI</span>组件)</span><br><span class="line">            -<span class="attr">mapStateToProps</span>:映射状态，返回值是一个对象</span><br><span class="line">            -<span class="attr">mapDispatchToProps</span>:映射操作状态的方法，返回值是一个对象</span><br><span class="line">(<span class="number">3</span>).备注<span class="number">1</span>：容器组件中的store是靠props传进去的，而不是在容器组件中直接引入</span><br><span class="line">(<span class="number">4</span>).备注<span class="number">2</span>：mapDispatchToProps，也可以是一个对象</span><br></pre></td></tr></table></figure><h3 id="求和案例-react-redux优化"><a href="#求和案例-react-redux优化" class="headerlink" title="求和案例_react-redux优化"></a>求和案例_react-redux优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).容器组件和<span class="variable constant_">UI</span>组件整合一个文件</span><br><span class="line">(<span class="number">2</span>).无需自己给容器组件传递store，给&lt;<span class="title class_">App</span>/&gt;包裹一个&lt;<span class="title class_">Provider</span> store=&#123;store&#125;&gt;即可。</span><br><span class="line">(<span class="number">3</span>).使用了react-redux后也不用再自己检测redux中状态的改变了，容器组件可以自动完成这个工作。</span><br><span class="line">(<span class="number">4</span>).<span class="property">mapDispatchToProps</span>也可以简单的写成一个对象</span><br><span class="line">(<span class="number">5</span>).一个组件要和redux“打交道”要经过哪几步？</span><br><span class="line">    <span class="number">1</span>).定义好<span class="variable constant_">UI</span>组件---不暴露</span><br><span class="line">    <span class="number">2</span>).引入connect生成一个容器组件，并暴露，写法如下：</span><br><span class="line">            <span class="title function_">connect</span>(</span><br><span class="line">                <span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">key</span>:value&#125;), <span class="comment">//映射状态</span></span><br><span class="line">                &#123;<span class="attr">key</span>:xxxxxAction&#125; <span class="comment">//映射操作状态的方法</span></span><br><span class="line">            )(<span class="variable constant_">UI</span>组件)</span><br><span class="line">    <span class="number">3</span>).在<span class="variable constant_">UI</span>组件中通过<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">xxxxxxx</span>读取和操作状态</span><br></pre></td></tr></table></figure><h3 id="求和案例-react-redux数据共享版"><a href="#求和案例-react-redux数据共享版" class="headerlink" title="求和案例_react-redux数据共享版"></a>求和案例_react-redux数据共享版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).定义一个<span class="title class_">Pserson</span>组件，和<span class="title class_">Count</span>组件通过redux共享数据。</span><br><span class="line">(<span class="number">2</span>).为<span class="title class_">Person</span>组件编写：reducer、action，配置constant常量。</span><br><span class="line">(<span class="number">3</span>).重点：<span class="title class_">Person</span>的reducer和<span class="title class_">Count</span>的<span class="title class_">Reducer</span>要使用combineReducers进行合并，合并后的总状态是一个对象！！！</span><br><span class="line">(<span class="number">4</span>).交给store的是总reducer，最后注意在组件中取出状态的时候，记得“取到位”。</span><br></pre></td></tr></table></figure><h3 id="求和案例-react-redux开发者工具的使用"><a href="#求和案例-react-redux开发者工具的使用" class="headerlink" title="求和案例_react-redux开发者工具的使用"></a>求和案例_react-redux开发者工具的使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).<span class="property">yarn</span> add redux-devtools-<span class="title function_">extension</span></span><br><span class="line">(<span class="number">2</span>).<span class="property">store</span>中进行配置</span><br><span class="line">    <span class="keyword">import</span> &#123;composeWithDevTools&#125; <span class="keyword">from</span> <span class="string">&#x27;redux-devtools-extension&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">createStore</span>(allReducer,<span class="title function_">composeWithDevTools</span>(<span class="title function_">applyMiddleware</span>(thunk)))</span><br></pre></td></tr></table></figure><h3 id="求和案例-react-redux最终版"><a href="#求和案例-react-redux最终版" class="headerlink" title="求和案例_react-redux最终版"></a>求和案例_react-redux最终版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).所有变量名字要规范，尽量触发对象的简写形式。</span><br><span class="line">(<span class="number">2</span>).<span class="property">reducers</span>文件夹中，编写index.<span class="property">js</span>专门用于汇总并暴露所有的reducer</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2024/08/13/redux/redux.gif&quot; class=&quot;&quot; title=&quot;图片引用方法一&quot;&gt;


&lt;h3 id=&quot;求和案例-redux精简版&quot;&gt;&lt;a href=&quot;#求和案例-redux精简版&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="教程" scheme="https://wuchu.site/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Redux" scheme="https://wuchu.site/tags/Redux/"/>
    
    <category term="前端" scheme="https://wuchu.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vue中对axios进行封装</title>
    <link href="https://wuchu.site/2024/08/13/axios/"/>
    <id>https://wuchu.site/2024/08/13/axios/</id>
    <published>2024-08-13T12:38:08.000Z</published>
    <updated>2024-10-29T11:08:17.747Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Axios：这不是一种新技术，本质上还是对原生XMLHttpRequest的封装，可用于浏览器和nodejs的HTTP客户端，只不过它是基于Promise的，符合最新的ES规范。</strong></p></blockquote><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>安装axios包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add axios --save</span><br></pre></td></tr></table></figure><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>在src目录下新建axios文件夹，在里面新建index.js文件。里面对axios进行一系列封装，包括添加拦截器和封装请求。</p><p><strong>src-&gt;axios-&gt;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入安装的axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 导入elementUI错误消息提示</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Message</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="comment">// 导入路由</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;../router/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios请求实例,并暴</span></span><br><span class="line"><span class="keyword">const</span> myaxios = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;http://localhost:8080&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123; <span class="string">&#x27;X-Custom-Header&#x27;</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">myaxios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="comment">// 一般是添加token再发送</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">myaxios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="comment">// 如果业务逻辑错误</span></span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">status</span> || response.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果返回数据中code=500,或者是未登录401,权限错误403</span></span><br><span class="line">        <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">500</span> || response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">401</span> || response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">403</span>) &#123;</span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>: response.<span class="property">data</span>.<span class="property">message</span> &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是其他</span></span><br><span class="line">        <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">message</span>) &#123;</span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">success</span>(&#123; <span class="attr">message</span>: response.<span class="property">data</span>.<span class="property">message</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">code</span> === <span class="number">504</span> || error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">code</span> === <span class="number">404</span>) &#123;</span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;服务器被吃了( •̀ ω •́ )&#x27;</span> &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">code</span> === <span class="number">403</span>) &#123;</span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;权限不足，请联系管理员&#x27;</span> &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">code</span> === <span class="number">401</span>) &#123;</span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;尚未登录，请登录！&#x27;</span> &#125;);</span><br><span class="line">        <span class="comment">//跳往登录界面</span></span><br><span class="line">        router.<span class="title function_">push</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">message</span>) &#123;</span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>: error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">message</span> &#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>:<span class="string">&#x27;未知错误去( •̀ ω •́ )✧&#x27;</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//暴露接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myaxios;</span><br></pre></td></tr></table></figure><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>在main.js文件中全局引入配置好的myaxios。这样你在任何一个组件里都可以使用<code>this.$axios.get()、this.$axiso.post()</code> 等等直接向服务器发送请求。</p><p> <strong>main.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> myaxios <span class="keyword">from</span> <span class="string">&#x27;./utils/axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭vue的提示</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 给全局Vue实例对象添加axios属性</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$axios</span> = myaxios;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Axios：这不是一种新技术，本质上还是对原生XMLHttpRequest的封装，可用于浏览器和nodejs的HTTP客户端，只不过它是基于Promise的，符合最新的ES规范。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="前端" scheme="https://wuchu.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Axios" scheme="https://wuchu.site/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>PG复制槽的原理</title>
    <link href="https://wuchu.site/2024/08/12/replication-slots/"/>
    <id>https://wuchu.site/2024/08/12/replication-slots/</id>
    <published>2024-08-12T08:02:38.000Z</published>
    <updated>2024-10-29T11:28:26.809Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h3><p>在主从复制的过程中，如果连接突然断开，主库中有些WAL日志文件还没有被从库备份就被删除了，导致备份的数据丢失。</p><h3 id="2、复制槽"><a href="#2、复制槽" class="headerlink" title="2、复制槽"></a>2、复制槽</h3><ul><li><p>复制槽提供了一种办法确保主库不会“删除”还未发送到备库的WAL日志，也不会删除备库需要的多版本，即使备库掉线。</p></li><li><p>replication slot能够确保在主备断连后主库的wal仍不被清理，因为replication slot的状态信息是持久化保存的，即便从库断掉或主库重启，这些信息仍然不会丢掉或失效。</p></li><li><p>replication slots 是从postgresql 9.4引入的，主要是提供了一种自动化的方法来确保主库在所有的备库收到wal之前不会移除它们，并且主库也不会移除可能导致恢复冲突的行(需要配合hot_standby_feedback)，即使备库断开也是如此。</p></li><li><p>在没有启用replication slots的环境中，如果碰到 ERROR: requested WAL segment xxxx has already been removed 的错误，解决办法是要么提前开启了归档，要么重做slave，另外还可以在主库上设置wal_keep_segments 为更大的值。当然，如果备库停机时间太长，可能主库的WAL日志目录会被撑满，如果设置了复制槽，建议将WAL日志目录放在大容量硬盘上。</p></li><li><p>PG 复制槽用于记录主备流复制的状态，主要目的是防止 wal 日志被过早的删除，导致备库流复制中断。复制槽是有状态的，能够持久化到磁盘上，允许宕机、重启场景下进行恢复。在有复制槽的场景下，即使备库关闭很长时间，主库也会为其保留足够的 wal 日志，直到备库恢复接收完这些 wal 日志，主库才会将其删除。当然这也带来了新的问题，即如果备库永远不恢复，那么主库的 wal 日志就会永远保留，导致磁盘空间耗尽，这时需要人工介入处理。</p></li></ul><h3 id="3、创建复制槽的方式"><a href="#3、创建复制槽的方式" class="headerlink" title="3、创建复制槽的方式"></a>3、创建复制槽的方式</h3><ul><li>在主库上执行下述SQL语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_create_physical_replication_slot(<span class="string">&#x27;slot_s1&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>备库使用 pg_basebackup 创建备份时指定参数 -C -S 来创建复制槽</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pg_basebackup <span class="operator">-</span>h <span class="operator">*</span>.<span class="operator">*</span>.<span class="operator">*</span>.<span class="operator">*</span> <span class="operator">-</span>p <span class="number">5432</span> <span class="operator">-</span>R <span class="operator">-</span>C <span class="operator">-</span>S slot_s1 <span class="operator">-</span>D <span class="operator">/</span>data<span class="operator">/</span>pg<span class="operator">/</span></span><br><span class="line"><span class="operator">-</span>R 表示写复制相关的配置文件，指定了 <span class="operator">-</span>R 参数，启动备库自动创建流复制</span><br><span class="line"><span class="operator">-</span>C 表示自动在主库创建复制槽，复制槽名称为 <span class="operator">-</span>S 指定，<span class="operator">-</span>C 必须与 <span class="operator">-</span>S 同时使用</span><br><span class="line"><span class="operator">-</span>S slot_s1 参数指定复制槽名称，备份完成后会自动在 postgresql.auto.conf 文件里加上参数 primary_slot_name <span class="operator">=</span> <span class="string">&#x27;slot_s1&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4、启动备库并在主库上查看复制槽信息"><a href="#4、启动备库并在主库上查看复制槽信息" class="headerlink" title="4、启动备库并在主库上查看复制槽信息"></a>4、启动备库并在主库上查看复制槽信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_replication_slots;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_stat_replication;</span><br></pre></td></tr></table></figure><h3 id="5、为什么复制槽可以阻止wal日志被删除？"><a href="#5、为什么复制槽可以阻止wal日志被删除？" class="headerlink" title="5、为什么复制槽可以阻止wal日志被删除？"></a>5、为什么复制槽可以阻止wal日志被删除？</h3><p>ReplicationSlotsComputeRequiredLSN() 函数遍历所有复制槽，获取最小的 restart_lsn，将该值赋值给 XLogCtl-&gt;replicationSlotMinLSN。wal 日志的清除主要在 checkpoint 操作时进行，在创建 checkpoint 时，会调用 KeepLogSeg() 函数，依赖 XLogCtl-&gt;replicationSlotMinLSN 保留 wal 日志文件。<br>此外，ReplicationSlotsComputeRequiredXmin() 函数遍历所有复制槽，获取最小的 effective_xmin 和 effective_catalog_xmin，然后分别将其赋值给如下两个变量，这两个变量在事务快照等场景下会使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procArray-&gt;replication_slot_xmin</span><br><span class="line">procArray-&gt;replication_slot_catalog_xmin</span><br></pre></td></tr></table></figure><h3 id="6-PG-复制槽相关参数"><a href="#6-PG-复制槽相关参数" class="headerlink" title="6. PG 复制槽相关参数"></a>6. PG 复制槽相关参数</h3><ul><li>max_replication_slots，最大的复制槽数量，取值范围为 0 ~ 0x3FFFF，默认值为 10， 设置为 0 表示禁用复制槽。</li><li>wal_level &gt;&#x3D; replica</li></ul><h3 id="7-复制槽共享内存初始化"><a href="#7-复制槽共享内存初始化" class="headerlink" title="7. 复制槽共享内存初始化"></a>7. 复制槽共享内存初始化</h3><p>复制槽相关的数据结构存储在共享内存中，大小由 max_replication_slots 参数决定，每个复制槽由结构体 ReplicationSlot 表示，其成员变量 in_use 表示该复制槽元素是否正在被使用。</p><ul><li>ReplicationSlotsShmemSize()，计算复制槽共享内存大小</li><li>ReplicationSlotsShmemInit()，初始化共享内存</li></ul><h3 id="8-PG-复制槽的实现逻辑"><a href="#8-PG-复制槽的实现逻辑" class="headerlink" title="8. PG 复制槽的实现逻辑"></a>8. PG 复制槽的实现逻辑</h3><h4 id="8-1-创建复制槽"><a href="#8-1-创建复制槽" class="headerlink" title="8.1 创建复制槽"></a>8.1 创建复制槽</h4><p>创建复制槽的函数调用关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pg_create_physical_replication_slot</span>()</span><br><span class="line">    <span class="built_in">create_physical_replication_slot</span>()</span><br><span class="line">        <span class="built_in">ReplicationSlotCreate</span>()</span><br></pre></td></tr></table></figure><p>ReplicationSlotCreate() 函数实现了创建复制槽的功能，主要入参是复制槽名称，函数内部调用 ReplicationSlotValidateName() 函数对复制槽名称进行合法性检查。遍历共享内存中的 ReplicationSlot 数组，找到一个 in_use 为 0 的元素，对该元素的各成员进行初始化。遍历 ReplicationSlot 数组时，也会对复制槽名称是否出现同名进行检查，如果已有相同名称的复制槽则报错。最后调用 CreateSlotOnDisk() 函数，将复制槽的数据写入数据目录下的文件中，路径为 pg_replslot&#x2F;$slot_name&#x2F;state，文件内容为 ReplicationSlotOnDisk 结构体。</p><h4 id="8-2-启动复制槽"><a href="#8-2-启动复制槽" class="headerlink" title="8.2 启动复制槽"></a>8.2 启动复制槽</h4><p>在主库创建的复制槽需要在主备流复制启动后才能使用，备库发送 start replication 时可以指定复制槽名称来启动复制槽，函数调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PostgresMain</span>()</span><br><span class="line">    <span class="built_in">exec_replication_command</span>()</span><br><span class="line">        <span class="built_in">StartReplication</span>()</span><br><span class="line">            <span class="built_in">WalSndLoop</span>()</span><br></pre></td></tr></table></figure><h3 id="9-导出函数和视图"><a href="#9-导出函数和视图" class="headerlink" title="9. 导出函数和视图"></a>9. 导出函数和视图</h3><p>slotfuncs.c 源文件中定义了一些导出函数和视图给用户调用，用于操作复制槽。<br>函数： pg_create_physical_replication_slot() pg_create_logical_replication_slot() pg_drop_replication_slot() pg_get_replication_slots() pg_replication_slot_advance()<br>视图： pg_replication_slots</p><h3 id="10-复制槽相关问题"><a href="#10-复制槽相关问题" class="headerlink" title="10. 复制槽相关问题"></a>10. 复制槽相关问题</h3><h4 id="10-1-复制槽-dirty-表示什么？"><a href="#10-1-复制槽-dirty-表示什么？" class="headerlink" title="10.1 复制槽 dirty 表示什么？"></a>10.1 复制槽 dirty 表示什么？</h4><p>MyReplicationSlot-&gt;just_dirtied &#x3D; true; MyReplicationSlot-&gt;dirty &#x3D; true;<br>复制槽数据在共享内存与磁盘上都会进行存储，当共享内存中的数据发生变化，则会将 MyReplicationSlot-&gt;dirty 标记为 true，刷盘后标记为 false。相关代码可参见 ReplicationSlotPersist() 函数。</p><h4 id="10-2-为什么复制槽能够阻止-wal-日志被清除？"><a href="#10-2-为什么复制槽能够阻止-wal-日志被清除？" class="headerlink" title="10.2 为什么复制槽能够阻止 wal 日志被清除？"></a>10.2 为什么复制槽能够阻止 wal 日志被清除？</h4><p>ReplicationSlotsComputeRequiredLSN() 函数遍历所有复制槽，获取最小的 restart_lsn，将该值赋值给 XLogCtl-&gt;replicationSlotMinLSN。wal 日志的清除主要在 checkpoint 操作时进行，在创建 checkpoint 时，会调用 KeepLogSeg() 函数，依赖 XLogCtl-&gt;replicationSlotMinLSN 保留 wal 日志文件。<br>此外，ReplicationSlotsComputeRequiredXmin() 函数遍历所有复制槽，获取最小的 effective_xmin 和 effective_catalog_xmin，然后分别将其赋值给如下两个变量，这两个变量在事务快照等场景下会使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procArray-&gt;replication_slot_xmin</span><br><span class="line">procArray-&gt;replication_slot_catalog_xmin</span><br></pre></td></tr></table></figure><h4 id="10-3-逻辑复制槽与物理复制槽的区别"><a href="#10-3-逻辑复制槽与物理复制槽的区别" class="headerlink" title="10.3 逻辑复制槽与物理复制槽的区别"></a>10.3 逻辑复制槽与物理复制槽的区别</h4><p>逻辑复制槽与物理复制槽在源码上的区别是 slot-&gt;data.database 是不是为 0 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define SlotIsPhysical(slot) ((slot)-&gt;data.database == InvalidOid)</span><br><span class="line">#define SlotIsLogical(slot) ((slot)-&gt;data.database != InvalidOid)</span><br></pre></td></tr></table></figure><h4 id="10-4-复制槽的-xid-和-lsn-如何更新？"><a href="#10-4-复制槽的-xid-和-lsn-如何更新？" class="headerlink" title="10.4 复制槽的 xid 和 lsn 如何更新？"></a>10.4 复制槽的 xid 和 lsn 如何更新？</h4><p>在 wal sender 进程中接收备库发出的回馈信息，包含 feedbackXmin 和 feedbackCatalogXmin，这些信息被存储在 slot 的成员变量中，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slot-&gt;data.xmin = feedbackXmin;</span><br><span class="line">slot-&gt;effective_xmin = feedbackXmin;</span><br><span class="line">slot-&gt;data.catalog_xmin = feedbackCatalogXmin;</span><br><span class="line">slot-&gt;effective_catalog_xmin = feedbackCatalogXmin;</span><br></pre></td></tr></table></figure><p>函数调用关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WalSndLoop()</span><br><span class="line">    ProcessRepliesIfAny()</span><br><span class="line">        ProcessStandbyMessage()</span><br><span class="line">            ProcessStandbyHSFeedbackMessage()</span><br><span class="line">                PhysicalReplicationSlotNewXmin()</span><br></pre></td></tr></table></figure><p>lsn 的更新与逻辑复制有关，wal sender 进程在逻辑解码时，更新相关的 lsn，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slot-&gt;candidate_catalog_xmin = xmin;</span><br><span class="line">slot-&gt;candidate_xmin_lsn = current_lsn;</span><br><span class="line">slot-&gt;candidate_restart_valid = current_lsn;</span><br><span class="line">slot-&gt;candidate_restart_lsn = restart_lsn;</span><br></pre></td></tr></table></figure><p>函数调用关系如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WalSndLoop</span>()</span><br><span class="line">    <span class="built_in">XLogSendLogical</span>()</span><br><span class="line">        <span class="built_in">LogicalDecodingProcessRecord</span>()</span><br><span class="line">            <span class="built_in">DecodeStandbyOp</span>()</span><br><span class="line">                <span class="built_in">SnapBuildProcessRunningXacts</span>()</span><br><span class="line">                    <span class="built_in">LogicalIncreaseXminForSlot</span>()</span><br><span class="line">                    <span class="built_in">LogicalIncreaseRestartDecodingForSlot</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;headerlink&quot; title=&quot;1、背景&quot;&gt;&lt;/a&gt;1、背景&lt;/h3&gt;&lt;p&gt;在主从复制的过程中，如果连接突然断开，主库中有些WAL日志文件还没有被从库备份就被删除了，导致备份的数据丢失。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://wuchu.site/categories/PostgreSQL/"/>
    
    
    <category term="复制槽" scheme="https://wuchu.site/tags/%E5%A4%8D%E5%88%B6%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础知识</title>
    <link href="https://wuchu.site/2024/08/08/databse/"/>
    <id>https://wuchu.site/2024/08/08/databse/</id>
    <published>2024-08-08T03:26:08.000Z</published>
    <updated>2024-10-29T11:53:03.370Z</updated>
    
    <content type="html"><![CDATA[<p>数据库简答题</p><h3 id="典型数据库模型"><a href="#典型数据库模型" class="headerlink" title="典型数据库模型"></a>典型数据库模型</h3><p>层次数据模型、网状数据模型、关系数据模型、面向对象数据模型等</p><h3 id="mydql-postgres-oracle-mongodb"><a href="#mydql-postgres-oracle-mongodb" class="headerlink" title="mydql postgres oracle  mongodb"></a>mydql postgres oracle  mongodb</h3><h3 id="简述数据库、数据库系统、数据库管理系统"><a href="#简述数据库、数据库系统、数据库管理系统" class="headerlink" title="简述数据库、数据库系统、数据库管理系统"></a>简述数据库、数据库系统、数据库管理系统</h3><p>   数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按照一定的数据模型组织、描述和存储，具有较小的冗余度（redundancy）、较高的数据独立性（data independency）和易扩展性（scalability），可为各种用户共享。<br>    数据库系统是由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。<br>    数据库管理系统是位于操作系统和用户之间的一层数据管理软件。</p><h3 id="数据管理技术三个阶段、数据库系统阶段的特点"><a href="#数据管理技术三个阶段、数据库系统阶段的特点" class="headerlink" title="数据管理技术三个阶段、数据库系统阶段的特点"></a>数据管理技术三个阶段、数据库系统阶段的特点</h3><p>（1）人工管理阶段（2）文件系统阶段（3）数据库系统阶段<br>数据库系统阶段的特点：<br>① 数据结构化         ②数据的共享性高、冗余度低、易扩充<br>③ 数据独立性高       ④数据由数据库管理系统统一管理和控制</p><p>文件系统<br>数据库管理系统<br>某一应用现实世界<br>共享性差，冗余度大共享性高，冗余度小<br>记录内有结构，整体无结构整体结构化，用数据模型描述<br>应用程序控制由数据库管理系统提供数据安全性，完整性，并发控制和恢复能力<br>独立性差具有高度的物理独立性和一定的逻辑独立性</p><h3 id="DBMS支持那几种数据模型"><a href="#DBMS支持那几种数据模型" class="headerlink" title="DBMS支持那几种数据模型"></a>DBMS支持那几种数据模型</h3><p>常用的是层次模型、网状模型、关系模型（最重要）。新兴的是面向对象数据模型和对象关系数据模型。<br>（1）层次模型是指用树型结构表示实体及其之间的联系，树中每一个节点代表一个记录类型，树状结构表示实体型之间的联系。在一个层次模型中的限制条件是：有且仅有一个节点，无父节点，此节点为树的根；其他节点有且仅有一个父节点。<br>（2）网状模型：用有向图结构表示实体类型及实体间联系的数据结构模型称为网状模型。网状模型的数据结构主要有以下两个特征: ①允许一个以上的节点无双亲。 ②一个节点可以有多于一个的双亲。<br>（3）关系模型是数据模型中最重要的。关系实际上就是关系模式在某一时刻的状态或内容。关系模式是型，关系是它的值。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。但在实际当中，常常把关系模式和关系统称为关系。现实世界的实体以及实体间的各种联系均用关系来表示，从用户角度看，关系模型中数据的逻辑结构是一张二维表。</p><h3 id="数据库应用系统开发阶段"><a href="#数据库应用系统开发阶段" class="headerlink" title="数据库应用系统开发阶段"></a>数据库应用系统开发阶段</h3><p>（1）需求分析（2）系统设计（3）系统实现（4）系统测试（5）系统运行与维护</p><h3 id="典型数据库系统举例："><a href="#典型数据库系统举例：" class="headerlink" title="典型数据库系统举例："></a>典型数据库系统举例：</h3><p>Access、DBase(前两者为桌面型)、SQL Server、Oracle、IBM DB、My SQL、Sybase</p><h3 id="简述两类数据模型"><a href="#简述两类数据模型" class="headerlink" title="简述两类数据模型"></a>简述两类数据模型</h3><p>（1）概念模型。E-R模型是用E-R图来描述现实世界的概念模型。<br>一种表示方法：实体-联系方法（entity-relationship approach），常用E-R图表示。<br>实体之间的联系：一对一、一对多、多对一、多对多<br>（2）逻辑模型和物理模型<br>逻辑结构设计中，一个实体型转换为一个关系模式。</p><h3 id="数据库的三级模式、两级映射："><a href="#数据库的三级模式、两级映射：" class="headerlink" title="数据库的三级模式、两级映射："></a>数据库的三级模式、两级映射：</h3><p>（1）三级模式<br>     外模式又称子模式或用户模式，对应于用户级。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、定义对应于用户的数据记录(外模式)，也可以利用数据操纵语言(Data Manipulation Language，DML)对这些数据记录进行。外模式反映了数据库的用户观。<br>模式又称逻辑模式，对应于概念级。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据描述语言(Data Defination Language，DDL)来描述、定义的，体现了数据库系统的整体观。<br>    内模式又称存储模式，对应于物理级，它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义，它是数据库的存储观。<br>    在一个数据库系统中，只有唯一的数据库，因而作为定义、描述数据库存储结构的内模式和定义、描述数据库逻辑结构的模式也是唯一的，但建立在数据库系统之上的应用则是非常广泛、多样的，所以对应的外模式不唯一。<br>（2）两级映射<br>①外模式&#x2F;模式映像。当模式改变时，由数据库管理员对各个外模式&#x2F;模式映像作相应改变，可以使外模式保持不变。应用程序是依据外模式编写的，从而应用程序不用修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。②模式&#x2F;内模式映像 。当数据的存储结构改变时，由数据库管理员对模式&#x2F;内模式映像作相应改变，可以使模式保持不变，从而应用程序也不用改变。保证了数据与程序的物理独立性，简称数据的物理独立性。</p><h3 id="数据模型通常都是由数据结构、数据操作和完整性约束三个要素组成。"><a href="#数据模型通常都是由数据结构、数据操作和完整性约束三个要素组成。" class="headerlink" title="数据模型通常都是由数据结构、数据操作和完整性约束三个要素组成。"></a>数据模型通常都是由数据结构、数据操作和完整性约束三个要素组成。</h3><p>　　1）数据结构<br>　　数据结构用于描述数据库系统的静态特性。数据结构是所研究的对象类型的集合。这些对象是数据库的组成成分，是与数据类型、内容、性质有关的对象，例如关系模型中的域、属性、关系等。一旦数据结构定义好之后，一般不发生变化。<br>　　2）数据操作<br>　　数据操作用于描述数据库系统的动态特性。数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。数据库主要有查询和更新（包括插入、删除、修改）两大类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。<br>　　3）完整性约束<br>　　数据的约束条件是一组完整性规则的集合。完整性规则是给定的数据模型中数据及其联系所具有的制约和储存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。在关系模型中，一般关系必须满足实体完整性和参照完整性两个条件。</p><h3 id="主码的作用"><a href="#主码的作用" class="headerlink" title="主码的作用"></a>主码的作用</h3><p>（1）唯一标识每个元组<br>（2）与关联表的外码建立联系，链接两个表<br>（3）使用主码值来组织关系的存储<br>（4）使用主码索引快速检索数据</p><h3 id="数据操作："><a href="#数据操作：" class="headerlink" title="数据操作："></a>数据操作：</h3><p>关系模型中常用的关系操作包括查询和数据更新两大部分：<br>查询: 选择、投影、连接、除、并、差、交、笛卡尔积等，其中选择、投影、并、差、笛卡尔积是5种基本操作<br>数据更新:插入、删除、修改<br>集合运算符：并、交、差、乘<br>专门运算符：选择、投影、连接、除<br>基本运算符：选择、投影、并、差、笛卡尔积</p><p>关系模型中常用的关系操作包括：选择（Select）、投影（Project）、连接（Join）、除（Divide）、并（Union）、交(Intersection）、差（Difference）等查询（Query）操作，和插入（Insert）、删除（Delete）、修改（Update）操作两大部分。查询是其中最主要的部分。<br>关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合（set-at-a-time）的方式。相应地，非关系数据模型的数据操作方式则为一次一记录（record-at-a-time）的方式。</p><h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><pre><code>关系的完整性规则是对关系的某种约束条件。</code></pre><p>（1）实体完整性，指在基本关系表中主码取值的约束，以保证每个元组可以被标识。约束规则：非空、唯一。<br>（2）参照完整性，指关系间需要遵循的数据约束，以保证关系间关联列的数据一致性。参照完整性是指外码取值必须与现有主码值相对应。<br>（3）用户定义完整性，指用户根据具体业务对数据处理规则要求所定义的数据约束。用户可定义列的数据类型、取值范围、缺省值、是否允许为空、取值唯一性、数据依赖性。</p><h3 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h3><p>   设F是基本关系R的一个或一组属性，但不是关系R的码，如果F与基本关系S的主码 Ks相对应，则称F是基本关系R的外码（Foreign key），并称基本关系R为参照关系（Referencing relation），基本关系S为被参照关系（Referenced relation）或目标关系（Target relation）。关系R和S不一定是不同的关系。</p><h3 id="简述-SQL-语言的特点"><a href="#简述-SQL-语言的特点" class="headerlink" title="简述 SQL 语言的特点"></a>简述 SQL 语言的特点</h3><p>SQL 语言集数据查询、数据操纵、数据定义和数据控制功能于一体，充分体现了关系数据库语言的特点和优点。其特点如下：①综合统一 ②高度非过程化 ③面向集合的操作方式 ④以同一种语法结构提供多种操作方式 ⑤语言简洁，易学易用</p><h3 id="SQL语言类别"><a href="#SQL语言类别" class="headerlink" title="SQL语言类别"></a>SQL语言类别</h3><p>（1）数据定义语言DDL（data definition language）:创建、删除、修改数据库对象（包括数据库、表、索引）   Create&#x2F;drop&#x2F;alter  database&#x2F;table&#x2F;index<br>（2）数据操纵语言DML（data manipulation language）:增加、删除、修改数据库<br>Insert、update、 delete<br>（3）数据查询语言DQL（data query language）:对数据库进行查询   select<br>（4）数据控制语言DCL（data control language）:对数据库对象访问权进行控制<br>Grant(授权)、 deny(拒绝)、 revoke(撤销)</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><pre><code>在数据库中，索引是针对某个表中的一列或者几列建立的指向表中记录数据页的逻辑指针清单，可加快对数据表的快速信息检索，快速连接关联表，减少分组和排序时间。</code></pre><p>聚集索引与非聚集索引的区别：在聚集索引中，码值的逻辑顺序决定了表中相应行的物理顺序；在非聚集索引中，码值的逻辑顺序可以与表中相应行的物理顺序不同。</p><h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><p>（1）简化复杂的SQL查询操作。通过视图，开发人员可以将复杂的查询语句封装在视图内，使外部程序只需要简单方式访问该视图，便可获取所需数据。<br>（2）提高数据访问安全性。通过视图可以将基本数据表的部分敏感数据隐藏起来，外部用户无法得知完整数据，保护隐私，并降低数据库被攻击的风险。<br>（3）提供一定程度是数据逻辑独立性。当数据表的结构改变，只要视图的结构不变，应用程序可以不做修改。<br>（4）集中展示用户所感兴趣的特定部分。<br>（5）使用户能以多种角度看待同一数据。</p><h3 id="SQL主码约束和唯一约束有什么区别呢？"><a href="#SQL主码约束和唯一约束有什么区别呢？" class="headerlink" title="SQL主码约束和唯一约束有什么区别呢？"></a>SQL主码约束和唯一约束有什么区别呢？</h3><p>主码约束：由一列或多列的组合，其值能唯一的标识表中的每一行。<br>唯一约束：不允许数据库表在指定列上具有相同的值，但允许有空值。<br>区别：一个表可以定义多个唯一约束，但只能定义一个主码约束；空值的列上可以定义唯一约束，不能定义主键约束。</p><h3 id="什么是表？什么是视图？两者的区别和联系是什么？"><a href="#什么是表？什么是视图？两者的区别和联系是什么？" class="headerlink" title="什么是表？什么是视图？两者的区别和联系是什么？"></a>什么是表？什么是视图？两者的区别和联系是什么？</h3><p>表是实实在在得保存数据的实体,写入的数据都保存在表中；<br>视图是从一个或几个基本表导出的表，它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。视图一经定义就可以像基本表一样被查询、删除，也可以在一个视图之上再定义新的视图，但是对视图的更新操作有限制。<br>联系： 视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。</p><h3 id="说明等值连接与自然连接的区别与联系？"><a href="#说明等值连接与自然连接的区别与联系？" class="headerlink" title="说明等值连接与自然连接的区别与联系？"></a>说明等值连接与自然连接的区别与联系？</h3><p>自然连接是除去重复属性的等值连接。 两者之间的区别和联系如下：<br>（1）自然连接一定是等值连接，但等值连接不一定是自然连接；<br>（2）等值连接要求相等的分量，不一定是公共属性；而自然连接要求相等的分量必须是公共属性；<br>（3）等值连接不把重复的属性除去；而自然连接要把重复的属性除去。</p><h3 id="数据字典通常包含五个部分：数据项、数据结构、数据流、数据存储、处理过程"><a href="#数据字典通常包含五个部分：数据项、数据结构、数据流、数据存储、处理过程" class="headerlink" title="数据字典通常包含五个部分：数据项、数据结构、数据流、数据存储、处理过程"></a>数据字典通常包含五个部分：数据项、数据结构、数据流、数据存储、处理过程</h3><h3 id="范式：1NF-2NF-3NF-BCNF-First-Normal-Form-Boycee-Codd-Normal-Form"><a href="#范式：1NF-2NF-3NF-BCNF-First-Normal-Form-Boycee-Codd-Normal-Form" class="headerlink" title="范式：1NF  2NF   3NF   BCNF    First Normal Form    Boycee Codd Normal Form"></a>范式：1NF  2NF   3NF   BCNF    First Normal Form    Boycee Codd Normal Form</h3><p>1NF：每个属性都不可再分<br>2NF：在1NF的基础之上，消除了非主属性对于码的部分函数依赖<br>3NF：在2NF的基础之上，消除了非主属性对于码的传递函数依赖<br>BCNF：在3NF的基础上，消除主属性对于码的部分函数依赖与传递函数依赖</p><p>1NF有哪些缺点？<br>1、数据冗余太大（每一个系的系主任名字重复出现）<br>2、更新异常（某个系更换系主任之后，必须将该系学生有关的每一个元组）<br>3、插入异常（如果一个系刚成立，尚无学生，就无法将老师存入到数据库中）<br>4、删除异常（如果学生都毕业了，在删除学生时，把这个系的系主任的所有信息都删除了）</p><h3 id="E-R模型到关系模型的转换"><a href="#E-R模型到关系模型的转换" class="headerlink" title="E-R模型到关系模型的转换"></a>E-R模型到关系模型的转换</h3><p>（1）将每一个实体转换成关系表，实体的属性转换为表的列，实体的标识符转换为表的主码；<br>（2）将实体间的关系转换为表间的参照完整性约束，即通过设置外码来参照主码。</p><h3 id="数据库管理员DBA的职责："><a href="#数据库管理员DBA的职责：" class="headerlink" title="数据库管理员DBA的职责："></a>数据库管理员DBA的职责：</h3><p>①决定数据库中的信息内容和结构：数据库中要存放哪些信息<br>②决定数据库的存储结构和存取策略：获得较高的存取效率和存储空间利用率<br>③定义数据的安全性要求和完整性约束条件：负责确定各个用户对数据库的存取权限、数<br>据的保密级别和完整性约束条件<br>④监控数据库的使用和运行：转储数据、维护日志文件、故障恢复<br>①数据库的改进和重组重构：对运行情况进行记录、统计分析，以此来不断改进数据库设计</p><h3 id="事务管理与事务"><a href="#事务管理与事务" class="headerlink" title="事务管理与事务"></a>事务管理与事务</h3><p>事务管理：在数据库应用系统中，完成一个业务处理通常需要多个操作步骤。在每个操作步骤中，都可能遭遇失败，若没有一个处理机制，就可能造成操作数据混乱，从而破坏数据一致性。<br>事务：指由构成单个业务处理单元的一组数据库访问操作，它们要么都正常执行，要么都不执行，是一个不可分割的工作单位。在关系数据库中，⼀个事务可以是⼀条SQL语句、⼀组SQL语句或者整个程序。事务通常以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。COMMIT表⽰提交，即提交事务 的所有操作。具体的说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。 ROLLBACK表⽰回滚，即在事务运⾏的过程中发⽣了某种故障，事务不能继续执⾏，系统将事务中对数据库的所 有已完成的操作全部撤销，回滚到事务开始时的状态。</p><p>事务ACID特性：<br>原子性（Atomicity）：事务的所有操作在数据库中要么全部执行，要么都不执行。<br>一致性（Consistency）：事务多次执行，结果应一致<br>隔离性（Isolation）：事务与事务之间隔离，并执行透明<br>持续性（Durability）：事务完成后，数据该改变必须是永久的</p><h3 id="为什么要进行数据库转储，比较各种数据转储方法？"><a href="#为什么要进行数据库转储，比较各种数据转储方法？" class="headerlink" title="为什么要进行数据库转储，比较各种数据转储方法？"></a>为什么要进行数据库转储，比较各种数据转储方法？</h3><p>所谓转储即DBA定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本称为后备副本或后援副本。当数据库遭到破坏后可以将后备副本重新装入，但重装后备副本只能将数据库恢复到转储时的状态，要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务。转储可分为静态转储和动态转储。转储还可以分为海量转储和增量转储两种方式。海量转储是指每次转储全部数据库。增量转储则指每次只转储上一次转储后更新过的数据。从恢复角度看，使用海量转储得到的后备副本进行恢复一般说来会更方便些。但如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效。</p><h3 id="并发控制可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？"><a href="#并发控制可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？" class="headerlink" title="并发控制可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？"></a>并发控制可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？</h3><p>并发操作带来的数据不一致性包括三类：丢失修改、不可重复读和读“脏”数据。产生数据不一致性的主要原因是并发操作破坏了事务的隔离性。并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其它事务的干扰，从而避免造成数据的不一致性。并发控制的主要技术是封锁（Locking）。<br>丢失修改：当一个事务修改了数据，并且这种修改还没有提交到数据库中时，另外一个事务又对同样的数据进行了修改，并且把这种修改提交到了数据库中。这样，数据库中没有出现第一个事务修改数据的结果，好像这种数据修改丢失了一样。<br>不可重复读：在一个事务内，多次读同一数据。在这个事务还没有结束时，另一个事务也访问该同一数据，那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，第一个事务两次读到的数据可能不一样。<br>读“脏”数据：当一个事务正在访问数据，并对数据进行了修改，而这种修改还没有提交到数据库中，这时另一个事务也访问这个数据并使用了这个数据。因为这个数据是还没有提交的数据，那么另一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p><h3 id="数据库完整性与安全性的区别"><a href="#数据库完整性与安全性的区别" class="headerlink" title="数据库完整性与安全性的区别"></a>数据库完整性与安全性的区别</h3><p>完整性和安全性是两个不同的概念。前者是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出造成的无效操作和错误结果，而后者是防止数据库被恶意的破坏和非法的存取。当然，完整性和安全性是密切相关的。特别是从系统实现的方法来看，某一种机制常常既可以用于安全保护亦可用于完整性保证。</p><h3 id="日志文件的定义与作用。"><a href="#日志文件的定义与作用。" class="headerlink" title="日志文件的定义与作用。"></a>日志文件的定义与作用。</h3><p>日志文件是用来记录事务对数据库的更新操作的文件。作用：在数据库恢复中起着重要的作用，可以用来进行事物故障恢复和系统故障恢复，并协助后备副本进行介质故障恢复。</p><h3 id="数据库恢复策略有哪几种？"><a href="#数据库恢复策略有哪几种？" class="headerlink" title="数据库恢复策略有哪几种？"></a>数据库恢复策略有哪几种？</h3><p>（1）数据转储（数据冗余）   （2）日志文件</p><h3 id="数据库：两段锁协议"><a href="#数据库：两段锁协议" class="headerlink" title="数据库：两段锁协议"></a>数据库：两段锁协议</h3><p>两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁。在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；在释放一个封锁之后，事务不再申请和获得任何其他封锁。<br>“两段”的含义是，事务分为两个阶段：第一阶段是获得封锁，也称为扩展阶段。在这阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁。第二阶段是释放封锁，也称为收缩阶段。在这阶段，事务释放已经获得的锁，但是不能再申请任何锁。<br>    可以证明，若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策 略都是可串行化的。 另外要注意两段锁协议和防止死锁的一次封锁法的异同之处。一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议；但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。</p><h3 id="数据库故障的种类？"><a href="#数据库故障的种类？" class="headerlink" title="数据库故障的种类？"></a>数据库故障的种类？</h3><p>1、事务内部的故障2、系统故障3、介质故障4、计算机病毒</p><h3 id="数据库保护-访问-的内容有哪些？"><a href="#数据库保护-访问-的内容有哪些？" class="headerlink" title="数据库保护(访问)的内容有哪些？"></a>数据库保护(访问)的内容有哪些？</h3><p>① 利用权限机制和完整性约束防止非法数据进入数据库；<br>② 提供故障恢复能力；<br>② 提供并发访问控制。</p><h3 id="数据库有哪几种备份策略"><a href="#数据库有哪几种备份策略" class="headerlink" title="数据库有哪几种备份策略"></a>数据库有哪几种备份策略</h3><p>完全备份、事务日志备份、差异备份、文件备份。</p><h3 id="DBMS-的控制操作有哪些"><a href="#DBMS-的控制操作有哪些" class="headerlink" title="DBMS 的控制操作有哪些"></a>DBMS 的控制操作有哪些</h3><p>①数据的安全性保护；②数据的完整性检查；③并发控制；④数据库恢复。</p><h3 id="DBMS的数据控制功能有那些"><a href="#DBMS的数据控制功能有那些" class="headerlink" title="DBMS的数据控制功能有那些"></a>DBMS的数据控制功能有那些</h3><p>（1）数据定义功能。DBMS提供相应数据语言来定义（DDL）数据库结构，它们是刻画数据库框架，并被保存在数据字典中。<br>（2）数据存取功能。DBMS提供数据操纵语言（DML），实现对数据库数据的基本存取操作：检索，插入，修改和删除。<br>（3）数据库运行管理功能。DBMS提供数据控制功能，即是数据的安全性、完整性和并发控制等对数据库运行进行有效地控制和管理，以确保数据正确有效。<br>（4）数据库的建立和维护功能。包括数据库初始数据的装入，数据库的转储、恢复、重组织，系统性能监视、分析等功能。<br>（5）数据库的传输。DBMS提供处理数据的传输，实现用户程序与DBMS之间的通信，通常与操作系统协调完成。</p><h3 id="Java语言设计数据库"><a href="#Java语言设计数据库" class="headerlink" title="Java语言设计数据库"></a>Java语言设计数据库</h3><p>创建数据库链结－&gt;创建语句对象－&gt;执行SQL命令-&gt;访问执行结果集-&gt;关闭链结<br>（1）利用JDBC API建立数据库连接，<br>（2）在建立的数据库连接上，执行SQL语句访问数据库<br>（3）在JSP中处理SQL执行结果<br>（4）在JSP中释放数据库连接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据库简答题&lt;/p&gt;
&lt;h3 id=&quot;典型数据库模型&quot;&gt;&lt;a href=&quot;#典型数据库模型&quot; class=&quot;headerlink&quot; title=&quot;典型数据库模型&quot;&gt;&lt;/a&gt;典型数据库模型&lt;/h3&gt;&lt;p&gt;层次数据模型、网状数据模型、关系数据模型、面向对象数据模型等&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="数据库基础" scheme="https://wuchu.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="基础知识" scheme="https://wuchu.site/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql的日志系统</title>
    <link href="https://wuchu.site/2024/08/07/log/"/>
    <id>https://wuchu.site/2024/08/07/log/</id>
    <published>2024-08-07T03:58:29.000Z</published>
    <updated>2024-10-29T13:29:11.151Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、postgresql日志类型"><a href="#1、postgresql日志类型" class="headerlink" title="1、postgresql日志类型"></a>1、postgresql日志类型</h3><ol><li><strong>pg_log –&gt; log：</strong>数据库运行日志，如各种error信息，慢查询，服务器与DB的状态信息等，默认关闭，可以通过参数自定义存储位置，格式等</li><li><strong>pg_xlog –&gt; pg_wal：</strong>WAL日志，即重做日志，默认大小16MB，强制打开</li><li><strong>pg_clog –&gt; pg_xact：</strong>事务提交日志，记录事务的元数据，强制打开</li></ol><blockquote><p>在10.0版本开始，pg_xlog目录被重新命名为pg_wal，pg_clog目录被重命名为pg_xact,pg_log目录被重命名为log</p></blockquote><h3 id="2、pg-log的开启，修改postgresql-conf相关配置"><a href="#2、pg-log的开启，修改postgresql-conf相关配置" class="headerlink" title="2、pg_log的开启，修改postgresql.conf相关配置"></a>2、pg_log的开启，修改postgresql.conf相关配置</h3><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">##开启日志记录</span><br><span class="line">logging_collector = <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line">##stderr,csvlog,syslog,<span class="keyword">and</span> eventlog，默认stderr</span><br><span class="line">log_destination = <span class="string">&#x27;stderr&#x27;</span></span><br><span class="line"></span><br><span class="line">##日志保存路径</span><br><span class="line">log_directory = <span class="string">&#x27;/data/pg_data/log/&#x27;</span></span><br><span class="line"></span><br><span class="line">##日志文件格式</span><br><span class="line">log_filename = <span class="string">&#x27;postgresql-%Y-%m-%d_%H%M%S.log&#x27;</span></span><br><span class="line"></span><br><span class="line">##日志文件权限</span><br><span class="line">log_file_mode = <span class="number">0600</span></span><br><span class="line"></span><br><span class="line">##是否开启通过日志覆盖模式</span><br><span class="line">log_truncate_on_rotation = <span class="keyword">off</span></span><br><span class="line"></span><br><span class="line">##日志输出格式</span><br><span class="line">log_line_prefix = <span class="string">&#x27;%t:%r:%u@%d:[%p]:&#x27;</span></span><br><span class="line"></span><br><span class="line">##<span class="keyword">none</span>, ddl, mod, <span class="keyword">all</span>，需要记录的类型</span><br><span class="line">log_statement = <span class="string">&#x27;ddl&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3、WAL日志LSN（log-sequence-number）编号规则"><a href="#3、WAL日志LSN（log-sequence-number）编号规则" class="headerlink" title="3、WAL日志LSN（log sequence number）编号规则"></a>3、WAL日志LSN（log sequence number）编号规则</h3><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前的lsn号</span></span><br><span class="line"><span class="keyword">select</span> pg_current_wal_lsn();</span><br><span class="line"><span class="number">0</span>/<span class="number">3E4</span>E6A0</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看的当前lsn的wal日志文件名</span></span><br><span class="line"><span class="keyword">select</span> pg_walfile_name(pg_current_wal_lsn());</span><br><span class="line"><span class="number">000000030000000000000003</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前lsn的偏移量</span></span><br><span class="line"><span class="keyword">select</span> pg_walfile_name_offset(pg_current_wal_lsn());</span><br><span class="line">(<span class="number">000000030000000000000003</span>,<span class="number">15001248</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 16进制转换数值</span></span><br><span class="line"><span class="keyword">select</span> x<span class="string">&#x27;E4E6A0&#x27;</span>::<span class="type">int</span></span><br><span class="line"><span class="number">15001248</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 手动刷新wal</span></span><br><span class="line"><span class="keyword">select</span> pg_switch_wal();</span><br></pre></td></tr></table></figure><h3 id="4、WAL流程"><a href="#4、WAL流程" class="headerlink" title="4、WAL流程"></a>4、WAL流程</h3><ul><li>当数据库中的数据发生变更时：<ul><li>change发送时：将所有data buffer刷新到磁盘</li><li>commit发生时：wal buffer 中数据刷新到磁盘</li><li>checkpoint发送时：将所有data buffer刷新到磁盘<blockquote><p>“checkpoint”是一个事件，它会将所有在内存中的已修改数据页（data buffer）写入到磁盘上的数据文件中，同时更新日志文件确保在发生系统故障时可以恢复数据。</p></blockquote></li></ul></li><li>触发checkpoint触发场景：<ul><li>checkpoit相关配置</li><li>max_wal_size已满</li><li>checkpoit相关配置</li><li>max_wal_size已满</li></ul></li><li>checkpoit相关配置:<figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看checkpoint_timeout配置，默认5min</span></span><br><span class="line"><span class="keyword">show</span> checkpoint_timeout;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看max_wal_size配置，默认1GB</span></span><br><span class="line"><span class="keyword">show</span> max_wal_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- checkpoint_completion_target:指定检查点完成的目标。默认0.5</span></span><br><span class="line"><span class="comment">-- 可以降低checkpoint对性能的影，但是数值过大时在数据库出现故障时候，会比较危险</span></span><br><span class="line"><span class="keyword">show</span> checkpoint_completion_target;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、WAL日志解析工具使用"><a href="#5、WAL日志解析工具使用" class="headerlink" title="5、WAL日志解析工具使用"></a>5、WAL日志解析工具使用</h3><ul><li>10.x版本之后，使用pg_waldump解析WAL日志</li><li>10.x版本之前，使用pg_xlogdump解析WAL日志</li></ul><p>pg_waldump使用语法：</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_waldump [<span class="keyword">option</span>] … [startseg [endseg]]</span><br></pre></td></tr></table></figure><p>相关参数：</p><img src="/2024/08/07/log/image1.png" class="" title="图1"><p>执行结果：</p><img src="/2024/08/07/log/image2.png" class="" title="图2">]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、postgresql日志类型&quot;&gt;&lt;a href=&quot;#1、postgresql日志类型&quot; class=&quot;headerlink&quot; title=&quot;1、postgresql日志类型&quot;&gt;&lt;/a&gt;1、postgresql日志类型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://wuchu.site/categories/PostgreSQL/"/>
    
    
    <category term="日志" scheme="https://wuchu.site/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql中元组的隐藏字段与MVCC</title>
    <link href="https://wuchu.site/2024/08/07/mvcc/"/>
    <id>https://wuchu.site/2024/08/07/mvcc/</id>
    <published>2024-08-07T03:58:29.000Z</published>
    <updated>2024-10-29T11:09:13.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>看了两本书，对pg元组隐藏字段的描述都不太清楚，导致我很难理解隐藏字段值的变化原因，这里详细介绍隐藏一下pg中元组每个隐藏字段的意义。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>安装的pg版本为<code>11</code>，每个元组的头部信息在<code>HeapTupleHeaderData</code>中定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HeapTupleHeaderData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">HeapTupleFields t_heap; <span class="comment">//存放元组描述信息</span></span><br><span class="line">DatumTupleFields t_datum;</span><br><span class="line">&#125;t_choice;</span><br><span class="line"></span><br><span class="line">ItemPointerData t_ctid;<span class="comment">/*元组的存放位置，一般值为“（blockid,itemid）”  */</span></span><br><span class="line">uint16t_infomask2;<span class="comment">/* 属性和标识位 */</span></span><br><span class="line">uint16t_infomask;<span class="comment">/* 其他标识位 */</span></span><br><span class="line">uint8t_hoff;<span class="comment">/* 首部+位图+填充的长度 */</span></span><br><span class="line">bits8t_bits[<span class="number">1</span>];<span class="comment">/* bitmap of NULLs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>HeapTupleHeaderData中的<code>t_heap</code>存储着元组的一些描述信息，结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HeapTupleFields</span></span><br><span class="line">&#123;</span><br><span class="line">TransactionId t_xmin;   <span class="comment">/* 插入或修改事务的ID */</span></span><br><span class="line">TransactionId t_xmax;   <span class="comment">/* 删除或者锁定事务的ID */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">   CommandId t_cid;   <span class="comment">/* 插入或者删除的命令ID */</span></span><br><span class="line">   TransactionId t_xvac; <span class="comment">/* 执行vacuum full的事务ID */</span></span><br><span class="line">&#125;    t_field3;</span><br><span class="line">&#125; HeapTupleFields;</span><br></pre></td></tr></table></figure><p>经过分析源码，发现核心的隐藏字段有：<strong>t_ctid、t_xmin、t_xmax、t_cid</strong></p><p>执行命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> attname, attnum, attisdropped, attlen, attalign, attnotnull</span><br><span class="line"><span class="keyword">FROM</span> pg_catalog.pg_attribute <span class="keyword">WHERE</span> attrelid <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span>::regclass</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> attnum;</span><br></pre></td></tr></table></figure><p>发现实际表的隐藏字段如下所示：</p><img src="/2024/08/07/mvcc/image.png" class="" title="图一"><p>所以说源码中的字段跟实际隐藏字段的name有区别，对应关系：</p><table><thead><tr><th>源码字段</th><th>实际隐藏字段</th></tr></thead><tbody><tr><td>t_ctid</td><td>ctid</td></tr><tr><td>t_xmin</td><td>xmin</td></tr><tr><td>t_xmax</td><td>xmax</td></tr><tr><td>t_cid</td><td>cmax、cmin</td></tr></tbody></table><h3 id="隐藏字段详细分析"><a href="#隐藏字段详细分析" class="headerlink" title="隐藏字段详细分析"></a>隐藏字段详细分析</h3><h5 id="t-ctid"><a href="#t-ctid" class="headerlink" title="t_ctid"></a>t_ctid</h5><img src="/2024/08/07/mvcc/image.2.png" class="" title="图2️"> <img src="/2024/08/07/mvcc/image.4.png" class="" title="图3"><p>对应实际字段中的ctid，表示数据记录的物理行当信息，指的是一条记录位于哪个数据块的哪个位移上面。<br>格式<code>(blockid,itemid)</code>：拿上图其中的(0,1)来说；0表示块id；1表示在这块第一条记录。</p><ul><li><p><strong>当执行insert操作时，ctid的变化如下：</strong></p><img src="/2024/08/07/mvcc/image.5.png" class="" title="图4"><img src="/2024/08/07/mvcc/image.6.png" class="" title="图5"><p>看出来是顺序累加。</p></li><li><p><strong>当执行更新操作时，ctid的变化：</strong></p><img src="/2024/08/07/mvcc/image.7.png" class="" title="图6"><img src="/2024/08/07/mvcc/image.8.png" class="" title="图7"><img src="/2024/08/07/mvcc/image.11.png" class="" title="图8"><p>更新操作实际上就是先删除一条数据，再插入一条数据。但是这个删除并不会移除物理存储内容，也就是说（0，2）这个位置的元组还在，因此新插入的数据的ctid为（0，3）。<br>如果执行vacuum操作，再插入一条数据：</p><img src="/2024/08/07/mvcc/image.9.png" class="" title="图9"></li></ul><blockquote><p><strong>发现并不会在（0，2）位置上插入新数据？</strong><br><strong>分析：</strong>新插入的数据通常不会立即填充刚刚清理的空间，而是优先使用表末尾的空闲空间，这涉及到数据库的存储管理和性能优化策略。减少碎片化：优先使用表末尾的空闲空间可以减少数据文件的碎片化，提高查询性能。提高插入性能：插入新数据到表末尾的空闲空间比在表中间找到一个合适的空闲位置更高效。</p></blockquote><h5 id="t-xmin"><a href="#t-xmin" class="headerlink" title="t_xmin"></a>t_xmin</h5><p>存储的是产生这个元组的事务ID，可能是insert或者update语句</p><img src="/2024/08/07/mvcc/image.12.png" class="" title="图10"><h5 id="t-xmax"><a href="#t-xmax" class="headerlink" title="t_xmax"></a>t_xmax</h5><p>存储的是删除或者锁定这个元组的事务ID</p><h5 id="t-cid"><a href="#t-cid" class="headerlink" title="t_cid"></a>t_cid</h5><p>包含cmin和cmax两个字段，分别存储创建这个元组的Command ID和删除这个元组的Command ID。在事务执行期间，会给改期间执行的所以命令设置一个唯一ID，也就是Command ID。</p><h3 id="MVCC的可见性判断"><a href="#MVCC的可见性判断" class="headerlink" title="MVCC的可见性判断"></a>MVCC的可见性判断</h3><p>MVCC 可见性判断主要就是将元组的 xmin、xmax、cmin、cmax 以及 t_infomask 信息结合快照 snapshot 以及 CLOG 中的信息，根据可见性判断规则，决定一个元组是否可见。<br>可见性判断主要分为两个部分：</p><ul><li>对元组的 xmin 进行可见性判断，即 insert 该元组的事务是否已提交，是否可见。</li><li>对元组的 xmax 进行可见性判断，即该元组是否已被 update 或者 delete。</li></ul><p>为了简化逻辑，去除了一些兼容相关的干扰以及很少走到的一些代码路径。以下是关于元组 xmin 的判断规则：</p><p>1.如果元组 xmin 未提交，判断条件为：!(t_infomask &amp; HEAP_XMIN_COMMITTED)</p><p>1.1 如果元组的 xmin 无效，即 HeapTupleHeaderXminInvalid(tuple)，返回不可见</p><p>1.2 如果元组的 xmin 在当前事务（包含子事务）中</p><ul><li>1.2.1 如果元组的 cmin 大于等于 快照的 commandId，返回不可见</li><li>1.2.2 如果元组的 t_infomask 包含 HEAP_XMAX_INVALID 标记，即 xmax 无效，返回可见</li><li>1.2.3 如果元组的 t_infomask 仅包含 HEAP_XMAX_EXCL_LOCK，返回可见</li><li>1.2.4 如果元组的 xmax 不在当前事务中，设置标记 HEAP_XMAX_INVALID，返回可见</li><li>1.2.5 如果元组的 cmax 大于等于快照的 commandId，返回可见，否则返回不可见</li></ul><p>1.3 如果元组的 xmin 在快照的活跃事务列表中，返回不可见</p><p>1.4 如果元组的 xmin 在 clog 中已提交，设置标记 HEAP_XMIN_COMMITTED</p><p>1.5 设置标记 HEAP_XMIN_INVALID，返回不可见</p><p>2.如果元组的 xmin 已提交</p><p>2.1 如果元组的 xmin 未冻结并且 xmin 在快照活跃事务列表中，返回不可见</p><p><strong>到此说明元组的 xmin 已提交，即 insert 已提交，是否可见还得看 xmax，下面是关于 xmax 的判断规则</strong></p><p>3.t_infomask 标记包含 HEAP_XMAX_INVALID，返回可见</p><p>4.t_infomask 标记满足 HEAP_XMAX_IS_LOCKED_ONLY，返回可见</p><p>5.如果 t_infomask 不包含 HEAP_XMAX_COMMITTED</p><p>5.1 如果 xmax 在当前事务中</p><ul><li>5.1.1 cmax 大于等于快照的cid，返回可见</li><li>5.1.2 cmax 小于快照的 cid，返回不可见</li></ul><p>5.2 如果 xmax 在快照的活跃事务列表中，返回可见</p><p>5.3 如果 xmax 在 clog 中没有提交，设置标记 HEAP_XMAX_INVALID，返回可见</p><p>5.4 设置标记 HEAP_XMAX_COMMITTED</p><p>6.t_infomask 包含 HEAP_XMAX_COMMITTED</p><p>6.1 如果 xmax 在快照的活跃事务列表中，返回可见</p><p>除了以上描述的情况外，其他的都返回不可见</p><p>7.其他都是返回不可见</p><p>以上分析可以看出 MVCC 可见性判断的规则还是比较复杂的，考虑了很多场景，规则之间还有先后顺序依赖。总结可见性规则影响因素如下：</p><ul><li>xmin 是否已提交，是否有效</li><li>xmin 是否在当前会话的事务中</li><li>xmin 是否在快照活跃事务列表中</li><li>xmin 在 clog 中的状态</li><li>cmin 与 快照 cid 的大小比较</li><li>xmax 是否已提交，是否有效</li><li>xmax 是否在当前会话的事务中</li><li>xmax 是否在快照活跃事务列表中</li><li>xmax 在 clog 中的状态</li><li>cmax 与快照 cid 的大小比较</li></ul><p>关于可见性分析，有两点需要注意：</p><ol><li>即使是 select 查询，也可能会写 wal 日志，比如设置 HEAP_XMIN_COMMITTED 这个操作就会涉及写 wal 日志。</li><li>此外即使 insert 事务已提交，已经写入 CLOG，但是该事务的事务号还没有从活跃事务列表中删除，那么元组仍然是不可见的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;看了两本书，对pg元组隐藏字段的描述都不太清楚，导致我很难理解隐藏字段值的变化原因，这里详细介绍隐藏一下pg中元组每个隐藏字段的意义。&lt;/p</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://wuchu.site/categories/PostgreSQL/"/>
    
    
    <category term="MVCC" scheme="https://wuchu.site/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql的pg_hba.conf文件</title>
    <link href="https://wuchu.site/2024/08/07/pg_hba/"/>
    <id>https://wuchu.site/2024/08/07/pg_hba/</id>
    <published>2024-08-07T03:58:29.000Z</published>
    <updated>2024-10-29T11:53:25.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>该文件用于控制访问安全性，管理客户端对于PostgreSQL服务器的访问权限，内容包括：允许哪些用户连接到哪个数据库，允许哪些IP或者哪个网段的IP连接到本服务器，以及指定连接时使用的身份验证模式。</p></blockquote><p>查询pg_hba.conf的文件位置</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -<span class="type">name</span> pg_hba.conf</span><br></pre></td></tr></table></figure><p>查看pg_hba.conf的文件内容</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/lib/pgsql/<span class="number">12</span>/data/pg_hba.conf</span><br></pre></td></tr></table></figure><p>文件的核心内容</p><p>四个核心参数：<strong>TYPE DATABASE USER ADDRESS METHOD</strong></p><ul><li>TYPE：表示主机类型，值可能为：<br>若为 <code>local</code> 表示是unix-domain的socket连接，<br>若为 <code>host</code> 是TCP&#x2F;IP socket ，<br>若为 <code>hostssl</code> 是SSL加密的TCP&#x2F;IP socket。</li><li>DATABASE：表示数据库名称,值可能为：<br><code>all</code> ,<code>sameuser</code>,<code>samerole</code>,<code>replication</code>,<code>数据库名称</code> ,或者多个数据库名称用 <code>逗号</code>，注意ALL不匹配 replication</li><li>USER：表示用户名称，值可以为：<br><code>all</code>,<code>一个用户名</code>，<code>一组用户名</code> ，多个用户时，可以用 <code>,</code>逗号隔开，或者在用户名称前缀 <code>+</code> ;在USER和DATABASE字段，也可以写一个单独的文件名称用 <code>@</code> 前缀，该文件包含数据库名称或用户名称。</li><li>ADDRESS：该参数可以为<br><code>主机名称</code> 或者<code>IP/32(IPV4) </code>或 <code>IP/128(IPV6)</code>，主机名称以 <code>.</code>开头，<code>samehost</code>或<code>samenet</code> 匹配任意Ip地址 </li><li>METHOD：该值可以为”trust”, “reject”, “md5”, “password”, “scram-sha-256”,”gss”, “sspi”, “ident”, “peer”, “pam”, “ldap”, “radius” or “cert”。注意 若为<code>password</code>则发送的为明文密码</li></ul><blockquote><p><strong>注意</strong><br>修改该配置文件中的参数，必须重启 <code>postgreSql</code>服务,若要允许其它IP地址访问该主机数据库，则必须修改 <code>postgresql.conf</code> 中的参数 <code>listen_addresses</code> 为 <code>*</code><br>重启：pg_ctl reload 或者 执行 SELECT pg_reload_conf()</p></blockquote><p>例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TYPE     DATABASE      <span class="keyword">USER</span>          ADDRESS           <span class="keyword">METHOD</span></span><br><span class="line">host       <span class="keyword">all</span>          <span class="keyword">all</span>       <span class="number">10.10</span><span class="number">.56</span><span class="number">.17</span><span class="operator">/</span><span class="number">32</span>        md5</span><br></pre></td></tr></table></figure><ol><li>host   参数表示安装PostgreSQL的主机</li><li>all    第一个all 表示该主机上的所有数据库实例</li><li>all    第二个all 表示所有用户</li><li>10.10.56.17&#x2F;32  表示需要连接到主机的IP地址，32表示IPV4</li><li>md5    表示验证方式</li></ol><p>表示允许IP地址为10.10.56.17的所有用户可以通过MD5的密码验证方式连接主机上所有的数据库</p><p><strong>也可以指定某个网段</strong></p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TYPE</span>  <span class="keyword">DATABASE</span>        <span class="keyword">USER</span>            ADDRESS                 <span class="keyword">METHOD</span></span><br><span class="line">host    test            pgtest           <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span>               md5</span><br></pre></td></tr></table></figure><p>表示允许 <code>任意iP</code> 通过用户名为 <code>pgtest</code> 和md5的 <code>密码</code> 验证方式连接主机上 <code>test</code> 的数据库<br><strong>- 不进行密码验证</strong></p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TYPE</span>  <span class="keyword">DATABASE</span>        <span class="keyword">USER</span>            ADDRESS                 <span class="keyword">METHOD</span></span><br><span class="line">host    test            pgtest           <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span>               trust</span><br></pre></td></tr></table></figure><ul><li>表示任意IP地址的用户 <code>pgtest</code> 无需密码验证可直接连接访问该主机的 <code>test</code> 数据库</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;该文件用于控制访问安全性，管理客户端对于PostgreSQL服务器的访问权限，内容包括：允许哪些用户连接到哪个数据</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://wuchu.site/categories/PostgreSQL/"/>
    
    
    <category term="配置文件" scheme="https://wuchu.site/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
</feed>
