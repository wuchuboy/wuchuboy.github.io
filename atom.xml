<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梧杵</title>
  
  <subtitle>日常学习记录</subtitle>
  <link href="https://wuchu.site/atom.xml" rel="self"/>
  
  <link href="https://wuchu.site/"/>
  <updated>2024-10-28T16:24:57.684Z</updated>
  <id>https://wuchu.site/</id>
  
  <author>
    <name>吴楚</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XID用的太多怎么办</title>
    <link href="https://wuchu.site/2024/10/28/xid_deal/"/>
    <id>https://wuchu.site/2024/10/28/xid_deal/</id>
    <published>2024-10-28T15:54:40.000Z</published>
    <updated>2024-10-28T16:24:57.684Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-查看哪个库xid最小"><a href="#1-查看哪个库xid最小" class="headerlink" title="1.查看哪个库xid最小"></a>1.查看哪个库xid最小</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> datname,(<span class="number">2147483647</span><span class="operator">-</span>pg_catalog.age(datfrozenxid))::<span class="type">int</span> <span class="keyword">FROM</span> pg_database <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span>; </span><br></pre></td></tr></table></figure><h4 id="2-进入对应的库中，查看表年龄"><a href="#2-进入对应的库中，查看表年龄" class="headerlink" title="2.进入对应的库中，查看表年龄"></a>2.进入对应的库中，查看表年龄</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.oid::regclass <span class="keyword">as</span> table_name, pg_size_pretty(pg_relation_size(c.oid)), greatest(age(c.relfrozenxid),age(t.relfrozenxid)) <span class="keyword">as</span> age <span class="keyword">FROM</span> pg_class c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_class t <span class="keyword">ON</span> c.reltoastrelid <span class="operator">=</span> t.oid <span class="keyword">WHERE</span> c.relkind <span class="keyword">IN</span> (<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;m&#x27;</span>) <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h4 id="3-对小的表执行vacuum，如果全库都低，直接全库清理；"><a href="#3-对小的表执行vacuum，如果全库都低，直接全库清理；" class="headerlink" title="3.对小的表执行vacuum，如果全库都低，直接全库清理；"></a>3.对小的表执行vacuum，如果全库都低，直接全库清理；</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单表清理：vacuum verbose 表名;</span><br><span class="line">全库清理：vacuum verbose;</span><br></pre></td></tr></table></figure><h4 id="4-注意执行的时候新起一个会话，看看自己的vacuum有没有被autovacuum阻塞。如果有的话，可以干掉autovacuum"><a href="#4-注意执行的时候新起一个会话，看看自己的vacuum有没有被autovacuum阻塞。如果有的话，可以干掉autovacuum" class="headerlink" title="4.注意执行的时候新起一个会话，看看自己的vacuum有没有被autovacuum阻塞。如果有的话，可以干掉autovacuum"></a>4.注意执行的时候新起一个会话，看看自己的vacuum有没有被autovacuum阻塞。如果有的话，可以干掉autovacuum</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pid, state,wait_event,wait_event_type,usename, <span class="built_in">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> (now()<span class="operator">-</span>query_start)), substr(query, <span class="number">0</span>, <span class="number">150</span>) <span class="keyword">from</span> pg_stat_activity <span class="keyword">where</span> state <span class="operator">!=</span> <span class="string">&#x27;idle&#x27;</span> <span class="keyword">and</span> <span class="built_in">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> (now()<span class="operator">-</span>xact_start)) <span class="operator">&gt;</span> <span class="number">300</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_terminate_backend(<span class="number">33431</span>);</span><br></pre></td></tr></table></figure><blockquote><p>确保机器内存足够的情况下增大内存参数可以加速清理：set maintenance_work_mem &#x3D; ‘10GB’; </p></blockquote><p>xid降低的原因：</p><ul><li>1.业务xid消耗过快或者autovacuum速度慢，先手动清理。这种情况下通过调整实例autovacuum相关参数，加快实例清理。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">autovacuum_analyze_scale_factor</span><br><span class="line">autovacuum_analyze_threshold</span><br><span class="line">autovacuum_vacuum_scale_factor</span><br><span class="line">autovacuum_vacuum_threshold</span><br><span class="line">autovacuum_vacuum_cost_limit</span><br><span class="line">autovacuum_vacuum_cost_delay</span><br></pre></td></tr></table></figure><ul><li>2.slot残留，联系用户清理，紧急情况下，自行清理。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">处理方法：</span><br><span class="line">查询：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_replication_slots <span class="keyword">where</span> active<span class="operator">=</span><span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">清理：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_drop_replication_slot(【slots_name】);</span><br></pre></td></tr></table></figure><ul><li>3.长事务残留，联系用户清理，紧急情况下，自行清理。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pid, state,wait_event,wait_event_type,usename, <span class="built_in">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> (now()<span class="operator">-</span>query_start)), substr(query, <span class="number">0</span>, <span class="number">150</span>) <span class="keyword">from</span> pg_stat_activity <span class="keyword">where</span> state <span class="operator">!=</span> <span class="string">&#x27;idle&#x27;</span> <span class="keyword">and</span> <span class="built_in">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> (now()<span class="operator">-</span>xact_start)) <span class="operator">&gt;</span> <span class="number">300</span>;</span><br></pre></td></tr></table></figure><ul><li><p>4.autovacuum_freeze_max_age参数设置过大，导致没有触发autovacuum，联系用户处理</p></li><li><p>5.临时表所在的会话未断开，阻塞xid回收，联系用户杀掉长连接，或者重启实例</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看剩余的xid：</span><br><span class="line"><span class="keyword">SELECT</span> datname,(<span class="number">2147483647</span><span class="operator">-</span>pg_catalog.age(datfrozenxid))::<span class="type">int</span> <span class="keyword">FROM</span> pg_database <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">每个表的年龄排序：</span><br><span class="line"><span class="keyword">SELECT</span> c.oid::regclass <span class="keyword">as</span> table_name, pg_size_pretty(pg_relation_size(c.oid)), greatest(age(c.relfrozenxid),age(t.relfrozenxid)) <span class="keyword">as</span> age <span class="keyword">FROM</span> pg_class c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_class t <span class="keyword">ON</span> c.reltoastrelid <span class="operator">=</span> t.oid <span class="keyword">WHERE</span> c.relkind <span class="keyword">IN</span> (<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;m&#x27;</span>) <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="报错处理方法："><a href="#报错处理方法：" class="headerlink" title="报错处理方法："></a>报错处理方法：</h3><blockquote><p>ERROR:  found xmin 414915252 from before relfrozenxid 794253244</p></blockquote><p>该报错为PG老版本bug导致，需要清理一下relcache，有两种方法：</p><ul><li>1、重启数据库，重启后会重新读入新数据内容到relcache中，相当于刷新relcache。</li><li>2、移除对应数据目录中的pg_internal.init文件，数据库会自动生成一个新的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-查看哪个库xid最小&quot;&gt;&lt;a href=&quot;#1-查看哪个库xid最小&quot; class=&quot;headerlink&quot; title=&quot;1.查看哪个库xid最小&quot;&gt;&lt;/a&gt;1.查看哪个库xid最小&lt;/h4&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;ta</summary>
      
    
    
    
    
    <category term="postgresql" scheme="https://wuchu.site/tags/postgresql/"/>
    
  </entry>
  
  <entry>
    <title>Redux的基本原理</title>
    <link href="https://wuchu.site/2024/08/13/redux/"/>
    <id>https://wuchu.site/2024/08/13/redux/</id>
    <published>2024-08-13T12:43:52.000Z</published>
    <updated>2024-10-28T16:26:07.802Z</updated>
    
    <content type="html"><![CDATA[<img src="/2024/08/13/redux/redux.gif" class="" title="图片引用方法一"><h3 id="求和案例-redux精简版"><a href="#求和案例-redux精简版" class="headerlink" title="求和案例_redux精简版"></a>求和案例_redux精简版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).去除<span class="title class_">Count</span>组件自身的状态</span><br><span class="line">(<span class="number">2</span>).<span class="property">src</span>下建立:</span><br><span class="line">    -redux</span><br><span class="line">        -store.<span class="property">js</span></span><br><span class="line">        -count_reducer.<span class="property">js</span></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>).<span class="property">store</span>.<span class="property">js</span>：</span><br><span class="line">    <span class="number">1</span>).引入redux中的createStore函数，创建一个store</span><br><span class="line">    <span class="number">2</span>).<span class="property">createStore</span>调用时要传入一个为其服务的reducer</span><br><span class="line">    <span class="number">3</span>).记得暴露store对象</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>).<span class="property">count_reducer</span>.<span class="property">js</span>：</span><br><span class="line">    <span class="number">1</span>).<span class="property">reducer</span>的本质是一个函数，接收：preState,action，返回加工后的状态</span><br><span class="line">    <span class="number">2</span>).<span class="property">reducer</span>有两个作用：初始化状态，加工状态</span><br><span class="line">    <span class="number">3</span>).<span class="property">reducer</span>被第一次调用时，是store自动触发的，</span><br><span class="line">                    传递的preState是<span class="literal">undefined</span>,</span><br><span class="line">                    传递的action是:&#123;<span class="attr">type</span>:<span class="string">&#x27;@@REDUX/INIT_a.2.b.4&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>).在index.<span class="property">js</span>中监测store中状态的改变，一旦发生改变重新渲染&lt;<span class="title class_">App</span>/&gt;</span><br><span class="line">    备注：redux只负责管理状态，至于状态的改变驱动着页面的展示，要靠我们自己写。</span><br></pre></td></tr></table></figure><h3 id="求和案例-redux完整版"><a href="#求和案例-redux完整版" class="headerlink" title="求和案例_redux完整版"></a>求和案例_redux完整版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新增文件：</span><br><span class="line"><span class="number">1.</span>count_action.<span class="property">js</span> 专门用于创建action对象</span><br><span class="line"><span class="number">2.</span>constant.<span class="property">js</span> 放置容易写错的type值</span><br></pre></td></tr></table></figure><h3 id="求和案例-redux异步action版"><a href="#求和案例-redux异步action版" class="headerlink" title="求和案例_redux异步action版"></a>求和案例_redux异步action版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).明确：延迟的动作不想交给组件自身，想交给<span class="title function_">action</span></span><br><span class="line">(<span class="number">2</span>).何时需要异步action：想要对状态进行操作，但是具体的数据靠异步任务返回。</span><br><span class="line">(<span class="number">3</span>).具体编码：</span><br><span class="line"><span class="number">1</span>).<span class="property">yarn</span> add redux-thunk，并配置在store中</span><br><span class="line"><span class="number">2</span>).创建action的函数不再返回一般对象，而是一个函数，该函数中写异步任务。</span><br><span class="line"><span class="number">3</span>).异步任务有结果后，分发一个同步的action去真正操作数据。</span><br><span class="line">(<span class="number">4</span>).备注：异步action不是必须要写的，完全可以自己等待异步任务的结果了再去分发同步action。</span><br></pre></td></tr></table></figure><h3 id="求和案例-react-redux基本使用"><a href="#求和案例-react-redux基本使用" class="headerlink" title="求和案例_react-redux基本使用"></a>求和案例_react-redux基本使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).明确两个概念：</span><br><span class="line">        <span class="number">1</span>).<span class="property">UI</span>组件:不能使用任何redux的api，只负责页面的呈现、交互等。</span><br><span class="line">        <span class="number">2</span>).容器组件：负责和redux通信，将结果交给<span class="variable constant_">UI</span>组件。</span><br><span class="line">(<span class="number">2</span>).如何创建一个容器组件————靠react-redux 的 connect函数</span><br><span class="line">        <span class="title function_">connect</span>(mapStateToProps,mapDispatchToProps)(<span class="variable constant_">UI</span>组件)</span><br><span class="line">            -<span class="attr">mapStateToProps</span>:映射状态，返回值是一个对象</span><br><span class="line">            -<span class="attr">mapDispatchToProps</span>:映射操作状态的方法，返回值是一个对象</span><br><span class="line">(<span class="number">3</span>).备注<span class="number">1</span>：容器组件中的store是靠props传进去的，而不是在容器组件中直接引入</span><br><span class="line">(<span class="number">4</span>).备注<span class="number">2</span>：mapDispatchToProps，也可以是一个对象</span><br></pre></td></tr></table></figure><h3 id="求和案例-react-redux优化"><a href="#求和案例-react-redux优化" class="headerlink" title="求和案例_react-redux优化"></a>求和案例_react-redux优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).容器组件和<span class="variable constant_">UI</span>组件整合一个文件</span><br><span class="line">(<span class="number">2</span>).无需自己给容器组件传递store，给&lt;<span class="title class_">App</span>/&gt;包裹一个&lt;<span class="title class_">Provider</span> store=&#123;store&#125;&gt;即可。</span><br><span class="line">(<span class="number">3</span>).使用了react-redux后也不用再自己检测redux中状态的改变了，容器组件可以自动完成这个工作。</span><br><span class="line">(<span class="number">4</span>).<span class="property">mapDispatchToProps</span>也可以简单的写成一个对象</span><br><span class="line">(<span class="number">5</span>).一个组件要和redux“打交道”要经过哪几步？</span><br><span class="line">    <span class="number">1</span>).定义好<span class="variable constant_">UI</span>组件---不暴露</span><br><span class="line">    <span class="number">2</span>).引入connect生成一个容器组件，并暴露，写法如下：</span><br><span class="line">            <span class="title function_">connect</span>(</span><br><span class="line">                <span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">key</span>:value&#125;), <span class="comment">//映射状态</span></span><br><span class="line">                &#123;<span class="attr">key</span>:xxxxxAction&#125; <span class="comment">//映射操作状态的方法</span></span><br><span class="line">            )(<span class="variable constant_">UI</span>组件)</span><br><span class="line">    <span class="number">3</span>).在<span class="variable constant_">UI</span>组件中通过<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">xxxxxxx</span>读取和操作状态</span><br></pre></td></tr></table></figure><h3 id="求和案例-react-redux数据共享版"><a href="#求和案例-react-redux数据共享版" class="headerlink" title="求和案例_react-redux数据共享版"></a>求和案例_react-redux数据共享版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).定义一个<span class="title class_">Pserson</span>组件，和<span class="title class_">Count</span>组件通过redux共享数据。</span><br><span class="line">(<span class="number">2</span>).为<span class="title class_">Person</span>组件编写：reducer、action，配置constant常量。</span><br><span class="line">(<span class="number">3</span>).重点：<span class="title class_">Person</span>的reducer和<span class="title class_">Count</span>的<span class="title class_">Reducer</span>要使用combineReducers进行合并，合并后的总状态是一个对象！！！</span><br><span class="line">(<span class="number">4</span>).交给store的是总reducer，最后注意在组件中取出状态的时候，记得“取到位”。</span><br></pre></td></tr></table></figure><h3 id="求和案例-react-redux开发者工具的使用"><a href="#求和案例-react-redux开发者工具的使用" class="headerlink" title="求和案例_react-redux开发者工具的使用"></a>求和案例_react-redux开发者工具的使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).<span class="property">yarn</span> add redux-devtools-<span class="title function_">extension</span></span><br><span class="line">(<span class="number">2</span>).<span class="property">store</span>中进行配置</span><br><span class="line">    <span class="keyword">import</span> &#123;composeWithDevTools&#125; <span class="keyword">from</span> <span class="string">&#x27;redux-devtools-extension&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">createStore</span>(allReducer,<span class="title function_">composeWithDevTools</span>(<span class="title function_">applyMiddleware</span>(thunk)))</span><br></pre></td></tr></table></figure><h3 id="求和案例-react-redux最终版"><a href="#求和案例-react-redux最终版" class="headerlink" title="求和案例_react-redux最终版"></a>求和案例_react-redux最终版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).所有变量名字要规范，尽量触发对象的简写形式。</span><br><span class="line">(<span class="number">2</span>).<span class="property">reducers</span>文件夹中，编写index.<span class="property">js</span>专门用于汇总并暴露所有的reducer</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2024/08/13/redux/redux.gif&quot; class=&quot;&quot; title=&quot;图片引用方法一&quot;&gt;


&lt;h3 id=&quot;求和案例-redux精简版&quot;&gt;&lt;a href=&quot;#求和案例-redux精简版&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="教程" scheme="https://wuchu.site/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="前端" scheme="https://wuchu.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Redux" scheme="https://wuchu.site/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Vue中对axios进行封装</title>
    <link href="https://wuchu.site/2024/08/13/axios/"/>
    <id>https://wuchu.site/2024/08/13/axios/</id>
    <published>2024-08-13T12:38:08.000Z</published>
    <updated>2024-10-28T16:25:55.079Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Axios：这不是一种新技术，本质上还是对原生XMLHttpRequest的封装，可用于浏览器和nodejs的HTTP客户端，只不过它是基于Promise的，符合最新的ES规范。</strong></p></blockquote><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>安装axios包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add axios --save</span><br></pre></td></tr></table></figure><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>在src目录下新建axios文件夹，在里面新建index.js文件。里面对axios进行一系列封装，包括添加拦截器和封装请求。</p><p><strong>src-&gt;axios-&gt;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入安装的axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 导入elementUI错误消息提示</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Message</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="comment">// 导入路由</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;../router/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios请求实例,并暴</span></span><br><span class="line"><span class="keyword">const</span> myaxios = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;http://localhost:8080&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123; <span class="string">&#x27;X-Custom-Header&#x27;</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">myaxios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="comment">// 一般是添加token再发送</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">myaxios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="comment">// 如果业务逻辑错误</span></span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">status</span> || response.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果返回数据中code=500,或者是未登录401,权限错误403</span></span><br><span class="line">        <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">500</span> || response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">401</span> || response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">403</span>) &#123;</span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>: response.<span class="property">data</span>.<span class="property">message</span> &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是其他</span></span><br><span class="line">        <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">message</span>) &#123;</span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">success</span>(&#123; <span class="attr">message</span>: response.<span class="property">data</span>.<span class="property">message</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">code</span> === <span class="number">504</span> || error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">code</span> === <span class="number">404</span>) &#123;</span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;服务器被吃了( •̀ ω •́ )&#x27;</span> &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">code</span> === <span class="number">403</span>) &#123;</span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;权限不足，请联系管理员&#x27;</span> &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">code</span> === <span class="number">401</span>) &#123;</span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;尚未登录，请登录！&#x27;</span> &#125;);</span><br><span class="line">        <span class="comment">//跳往登录界面</span></span><br><span class="line">        router.<span class="title function_">push</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">message</span>) &#123;</span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>: error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">message</span> &#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123; <span class="attr">message</span>:<span class="string">&#x27;未知错误去( •̀ ω •́ )✧&#x27;</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//暴露接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myaxios;</span><br></pre></td></tr></table></figure><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>在main.js文件中全局引入配置好的myaxios。这样你在任何一个组件里都可以使用<code>this.$axios.get()、this.$axiso.post()</code> 等等直接向服务器发送请求。</p><p> <strong>main.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> myaxios <span class="keyword">from</span> <span class="string">&#x27;./utils/axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭vue的提示</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 给全局Vue实例对象添加axios属性</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$axios</span> = myaxios;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Axios：这不是一种新技术，本质上还是对原生XMLHttpRequest的封装，可用于浏览器和nodejs的HTTP客户端，只不过它是基于Promise的，符合最新的ES规范。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="教程" scheme="https://wuchu.site/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Axios" scheme="https://wuchu.site/tags/Axios/"/>
    
    <category term="前端" scheme="https://wuchu.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>PG复制槽的原理</title>
    <link href="https://wuchu.site/2024/08/12/replication-slots/"/>
    <id>https://wuchu.site/2024/08/12/replication-slots/</id>
    <published>2024-08-12T08:02:38.000Z</published>
    <updated>2024-10-28T16:25:18.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-PG-复制槽？"><a href="#什么是-PG-复制槽？" class="headerlink" title="什么是 PG 复制槽？"></a>什么是 PG 复制槽？</h2><p>PG 复制槽用于记录主备流复制的状态，主要目的是防止 wal 日志被过早的删除，导致备库流复制中断。复制槽是有状态的，能够持久化到磁盘上，允许宕机、重启场景下进行恢复。在有复制槽的场景下，即使备库关闭很长时间，主库也会为其保留足够的 wal 日志，直到备库恢复接收完这些 wal 日志，主库才会将其删除。当然这也带来了新的问题，即如果备库永远不恢复，那么主库的 wal 日志就会永远保留，导致磁盘空间耗尽，这时需要人工介入处理。</p><h2 id="PG-复制槽相关参数"><a href="#PG-复制槽相关参数" class="headerlink" title="PG 复制槽相关参数"></a>PG 复制槽相关参数</h2><ul><li>max_replication_slots，最大的复制槽数量，取值范围为 0 ~ 0x3FFFF，默认值为 10， 设置为 0 表示禁用复制槽。</li><li>wal_level &gt;&#x3D; replica</li></ul><h2 id="复制槽共享内存初始化"><a href="#复制槽共享内存初始化" class="headerlink" title="复制槽共享内存初始化"></a>复制槽共享内存初始化</h2><p>复制槽相关的数据结构存储在共享内存中，大小由 max_replication_slots 参数决定，每个复制槽由结构体 ReplicationSlot 表示，其成员变量 in_use 表示该复制槽元素是否正在被使用。</p><ul><li>ReplicationSlotsShmemSize()，计算复制槽共享内存大小</li><li>ReplicationSlotsShmemInit()，初始化共享内存</li></ul><h2 id="PG-复制槽的实现逻辑"><a href="#PG-复制槽的实现逻辑" class="headerlink" title="PG 复制槽的实现逻辑"></a>PG 复制槽的实现逻辑</h2><h3 id="创建复制槽"><a href="#创建复制槽" class="headerlink" title="创建复制槽"></a>创建复制槽</h3><p>创建复制槽的函数调用关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pg_create_physical_replication_slot</span>()</span><br><span class="line">   <span class="built_in">create_physical_replication_slot</span>()</span><br><span class="line">     <span class="built_in">ReplicationSlotCreate</span>()</span><br></pre></td></tr></table></figure><p>ReplicationSlotCreate() 函数实现了创建复制槽的功能，主要入参是复制槽名称，函数内部调用 ReplicationSlotValidateName() 函数对复制槽名称进行合法性检查。遍历共享内存中的 ReplicationSlot 数组，找到一个 in_use为 0 的元素，对该元素的各成员进行初始化。遍历 ReplicationSlot 数组时，也会对复制槽名称是否出现同名进行检查，如果已有相同名称的复制槽则报错。最后调用 CreateSlotOnDisk() 函数，将复制槽的数据写入数据目录下的文件中，路径为 pg_replslot&#x2F;$slot_name&#x2F;state，文件内容为 ReplicationSlotOnDisk 结构体。</p><h3 id="启动复制槽"><a href="#启动复制槽" class="headerlink" title="启动复制槽"></a>启动复制槽</h3><p>在主库创建的复制槽需要在主备流复制启动后才能使用，备库发送 start replication 时可以指定复制槽名称来启动复制槽，函数调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PostgresMain</span>()</span><br><span class="line">    <span class="built_in">exec_replication_command</span>()</span><br><span class="line">        <span class="built_in">StartReplication</span>()</span><br><span class="line">            <span class="built_in">WalSndLoop</span>()</span><br></pre></td></tr></table></figure><h2 id="导出函数和视图"><a href="#导出函数和视图" class="headerlink" title="导出函数和视图"></a>导出函数和视图</h2><p>slotfuncs.c源文件中定义了一些导出函数和视图给用户调用，用于操作复制槽。</p><p>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pg_create_physical_replication_slot</span>()</span><br><span class="line"><span class="built_in">pg_create_logical_replication_slot</span>() </span><br><span class="line"><span class="built_in">pg_drop_replication_slot</span>() </span><br><span class="line"><span class="built_in">pg_get_replication_slots</span>() </span><br><span class="line"><span class="built_in">pg_replication_slot_advance</span>()</span><br></pre></td></tr></table></figure><p>视图： <code>pg_replication_slots</code></p><h2 id="复制槽相关问题"><a href="#复制槽相关问题" class="headerlink" title="复制槽相关问题"></a>复制槽相关问题</h2><h3 id="复制槽-dirty-表示什么？"><a href="#复制槽-dirty-表示什么？" class="headerlink" title="复制槽 dirty 表示什么？"></a>复制槽 dirty 表示什么？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyReplicationSlot-&gt;just_dirtied = <span class="literal">true</span>; </span><br><span class="line">MyReplicationSlot-&gt;dirty = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>复制槽数据在共享内存与磁盘上都会进行存储，当共享内存中的数据发生变化，则会将 MyReplicationSlot-&gt;dirty标记为true，刷盘后标记为 false。相关代码可参见 ReplicationSlotPersist() 函数。</p><h3 id="为什么复制槽能够阻止-wal-日志被清除？"><a href="#为什么复制槽能够阻止-wal-日志被清除？" class="headerlink" title="为什么复制槽能够阻止 wal 日志被清除？"></a>为什么复制槽能够阻止 wal 日志被清除？</h3><p>ReplicationSlotsComputeRequiredLSN() 函数遍历所有复制槽，获取最小的 restart_lsn，将该值赋值给 XLogCtl-&gt;replicationSlotMinLSN。wal 日志的清除主要在 checkpoint 操作时进行，在创建 checkpoint 时，会调用 KeepLogSeg() 函数，依赖 XLogCtl-&gt;replicationSlotMinLSN 保留 wal 日志文件。</p><p>此外，ReplicationSlotsComputeRequiredXmin() 函数遍历所有复制槽，获取最小的 effective_xmin 和 effective_catalog_xmin，然后分别将其赋值给如下两个变量，这两个变量在事务快照等场景下会使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procArray-&gt;replication_slot_xmin</span><br><span class="line">procArray-&gt;replication_slot_catalog_xmin</span><br></pre></td></tr></table></figure><h3 id="逻辑复制槽与物理复制槽的区别"><a href="#逻辑复制槽与物理复制槽的区别" class="headerlink" title="逻辑复制槽与物理复制槽的区别"></a>逻辑复制槽与物理复制槽的区别</h3><p>逻辑复制槽与物理复制槽在源码上的区别是 slot-&gt;data.database 是不是为 0 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SlotIsPhysical(slot) ((slot)-&gt;data.database == InvalidOid)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SlotIsLogical(slot) ((slot)-&gt;data.database != InvalidOid)</span></span><br></pre></td></tr></table></figure><h3 id="复制槽的-xid-和-lsn-如何更新？"><a href="#复制槽的-xid-和-lsn-如何更新？" class="headerlink" title="复制槽的 xid 和 lsn 如何更新？"></a>复制槽的 xid 和 lsn 如何更新？</h3><p>在 wal sender 进程中接收备库发出的回馈信息，包含 feedbackXmin 和 feedbackCatalogXmin，这些信息被存储在 slot 的成员变量中，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slot-&gt;data.xmin = feedbackXmin;</span><br><span class="line">slot-&gt;effective_xmin = feedbackXmin;</span><br><span class="line">slot-&gt;data.catalog_xmin = feedbackCatalogXmin;</span><br><span class="line">slot-&gt;effective_catalog_xmin = feedbackCatalogXmin;</span><br></pre></td></tr></table></figure><p>函数调用关系如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WalSndLoop</span>()</span><br><span class="line">    <span class="built_in">ProcessRepliesIfAny</span>()</span><br><span class="line">        <span class="built_in">ProcessStandbyMessage</span>()</span><br><span class="line">            <span class="built_in">ProcessStandbyHSFeedbackMessage</span>()</span><br><span class="line">                <span class="built_in">PhysicalReplicationSlotNewXmin</span>()</span><br></pre></td></tr></table></figure><p>lsn 的更新与逻辑复制有关，wal sender 进程在逻辑解码时，更新相关的 lsn，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slot-&gt;candidate_catalog_xmin = xmin;</span><br><span class="line">slot-&gt;candidate_xmin_lsn = current_lsn;</span><br><span class="line">slot-&gt;candidate_restart_valid = current_lsn;</span><br><span class="line">slot-&gt;candidate_restart_lsn = restart_lsn;</span><br></pre></td></tr></table></figure><p>函数调用关系如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WalSndLoop</span>()</span><br><span class="line">    <span class="built_in">XLogSendLogical</span>()</span><br><span class="line">        <span class="built_in">LogicalDecodingProcessRecord</span>()</span><br><span class="line">            <span class="built_in">DecodeStandbyOp</span>()</span><br><span class="line">                <span class="built_in">SnapBuildProcessRunningXacts</span>()</span><br><span class="line">                    <span class="built_in">LogicalIncreaseXminForSlot</span>()</span><br><span class="line">                        <span class="built_in">LogicalIncreaseRestartDecodingForSlot</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是-PG-复制槽？&quot;&gt;&lt;a href=&quot;#什么是-PG-复制槽？&quot; class=&quot;headerlink&quot; title=&quot;什么是 PG 复制槽？&quot;&gt;&lt;/a&gt;什么是 PG 复制槽？&lt;/h2&gt;&lt;p&gt;PG 复制槽用于记录主备流复制的状态，主要目的是防止 wal 日志被</summary>
      
    
    
    
    <category term="原理" scheme="https://wuchu.site/categories/%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="postgresql" scheme="https://wuchu.site/tags/postgresql/"/>
    
    <category term="复制槽" scheme="https://wuchu.site/tags/%E5%A4%8D%E5%88%B6%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础知识</title>
    <link href="https://wuchu.site/2024/08/08/databse/"/>
    <id>https://wuchu.site/2024/08/08/databse/</id>
    <published>2024-08-08T03:26:08.000Z</published>
    <updated>2024-10-28T14:32:30.972Z</updated>
    
    <content type="html"><![CDATA[<p>数据库简答题</p><h3 id="典型数据库模型"><a href="#典型数据库模型" class="headerlink" title="典型数据库模型"></a>典型数据库模型</h3><p>层次数据模型、网状数据模型、关系数据模型、面向对象数据模型等</p><h3 id="mydql-postgres-oracle-mongodb"><a href="#mydql-postgres-oracle-mongodb" class="headerlink" title="mydql postgres oracle  mongodb"></a>mydql postgres oracle  mongodb</h3><h3 id="简述数据库、数据库系统、数据库管理系统"><a href="#简述数据库、数据库系统、数据库管理系统" class="headerlink" title="简述数据库、数据库系统、数据库管理系统"></a>简述数据库、数据库系统、数据库管理系统</h3><p>   数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按照一定的数据模型组织、描述和存储，具有较小的冗余度（redundancy）、较高的数据独立性（data independency）和易扩展性（scalability），可为各种用户共享。<br>    数据库系统是由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。<br>    数据库管理系统是位于操作系统和用户之间的一层数据管理软件。</p><h3 id="数据管理技术三个阶段、数据库系统阶段的特点"><a href="#数据管理技术三个阶段、数据库系统阶段的特点" class="headerlink" title="数据管理技术三个阶段、数据库系统阶段的特点"></a>数据管理技术三个阶段、数据库系统阶段的特点</h3><p>（1）人工管理阶段（2）文件系统阶段（3）数据库系统阶段<br>数据库系统阶段的特点：<br>① 数据结构化         ②数据的共享性高、冗余度低、易扩充<br>③ 数据独立性高       ④数据由数据库管理系统统一管理和控制</p><p>文件系统<br>数据库管理系统<br>某一应用现实世界<br>共享性差，冗余度大共享性高，冗余度小<br>记录内有结构，整体无结构整体结构化，用数据模型描述<br>应用程序控制由数据库管理系统提供数据安全性，完整性，并发控制和恢复能力<br>独立性差具有高度的物理独立性和一定的逻辑独立性</p><h3 id="DBMS支持那几种数据模型"><a href="#DBMS支持那几种数据模型" class="headerlink" title="DBMS支持那几种数据模型"></a>DBMS支持那几种数据模型</h3><p>常用的是层次模型、网状模型、关系模型（最重要）。新兴的是面向对象数据模型和对象关系数据模型。<br>（1）层次模型是指用树型结构表示实体及其之间的联系，树中每一个节点代表一个记录类型，树状结构表示实体型之间的联系。在一个层次模型中的限制条件是：有且仅有一个节点，无父节点，此节点为树的根；其他节点有且仅有一个父节点。<br>（2）网状模型：用有向图结构表示实体类型及实体间联系的数据结构模型称为网状模型。网状模型的数据结构主要有以下两个特征: ①允许一个以上的节点无双亲。 ②一个节点可以有多于一个的双亲。<br>（3）关系模型是数据模型中最重要的。关系实际上就是关系模式在某一时刻的状态或内容。关系模式是型，关系是它的值。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。但在实际当中，常常把关系模式和关系统称为关系。现实世界的实体以及实体间的各种联系均用关系来表示，从用户角度看，关系模型中数据的逻辑结构是一张二维表。</p><h3 id="数据库应用系统开发阶段"><a href="#数据库应用系统开发阶段" class="headerlink" title="数据库应用系统开发阶段"></a>数据库应用系统开发阶段</h3><p>（1）需求分析（2）系统设计（3）系统实现（4）系统测试（5）系统运行与维护</p><h3 id="典型数据库系统举例："><a href="#典型数据库系统举例：" class="headerlink" title="典型数据库系统举例："></a>典型数据库系统举例：</h3><p>Access、DBase(前两者为桌面型)、SQL Server、Oracle、IBM DB、My SQL、Sybase</p><h3 id="简述两类数据模型"><a href="#简述两类数据模型" class="headerlink" title="简述两类数据模型"></a>简述两类数据模型</h3><p>（1）概念模型。E-R模型是用E-R图来描述现实世界的概念模型。<br>一种表示方法：实体-联系方法（entity-relationship approach），常用E-R图表示。<br>实体之间的联系：一对一、一对多、多对一、多对多<br>（2）逻辑模型和物理模型<br>逻辑结构设计中，一个实体型转换为一个关系模式。</p><h3 id="数据库的三级模式、两级映射："><a href="#数据库的三级模式、两级映射：" class="headerlink" title="数据库的三级模式、两级映射："></a>数据库的三级模式、两级映射：</h3><p>（1）三级模式<br>     外模式又称子模式或用户模式，对应于用户级。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、定义对应于用户的数据记录(外模式)，也可以利用数据操纵语言(Data Manipulation Language，DML)对这些数据记录进行。外模式反映了数据库的用户观。<br>模式又称逻辑模式，对应于概念级。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据描述语言(Data Defination Language，DDL)来描述、定义的，体现了数据库系统的整体观。<br>    内模式又称存储模式，对应于物理级，它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义，它是数据库的存储观。<br>    在一个数据库系统中，只有唯一的数据库，因而作为定义、描述数据库存储结构的内模式和定义、描述数据库逻辑结构的模式也是唯一的，但建立在数据库系统之上的应用则是非常广泛、多样的，所以对应的外模式不唯一。<br>（2）两级映射<br>①外模式&#x2F;模式映像。当模式改变时，由数据库管理员对各个外模式&#x2F;模式映像作相应改变，可以使外模式保持不变。应用程序是依据外模式编写的，从而应用程序不用修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。②模式&#x2F;内模式映像 。当数据的存储结构改变时，由数据库管理员对模式&#x2F;内模式映像作相应改变，可以使模式保持不变，从而应用程序也不用改变。保证了数据与程序的物理独立性，简称数据的物理独立性。</p><h3 id="数据模型通常都是由数据结构、数据操作和完整性约束三个要素组成。"><a href="#数据模型通常都是由数据结构、数据操作和完整性约束三个要素组成。" class="headerlink" title="数据模型通常都是由数据结构、数据操作和完整性约束三个要素组成。"></a>数据模型通常都是由数据结构、数据操作和完整性约束三个要素组成。</h3><p>　　1）数据结构<br>　　数据结构用于描述数据库系统的静态特性。数据结构是所研究的对象类型的集合。这些对象是数据库的组成成分，是与数据类型、内容、性质有关的对象，例如关系模型中的域、属性、关系等。一旦数据结构定义好之后，一般不发生变化。<br>　　2）数据操作<br>　　数据操作用于描述数据库系统的动态特性。数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。数据库主要有查询和更新（包括插入、删除、修改）两大类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。<br>　　3）完整性约束<br>　　数据的约束条件是一组完整性规则的集合。完整性规则是给定的数据模型中数据及其联系所具有的制约和储存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。在关系模型中，一般关系必须满足实体完整性和参照完整性两个条件。</p><h3 id="主码的作用"><a href="#主码的作用" class="headerlink" title="主码的作用"></a>主码的作用</h3><p>（1）唯一标识每个元组<br>（2）与关联表的外码建立联系，链接两个表<br>（3）使用主码值来组织关系的存储<br>（4）使用主码索引快速检索数据</p><h3 id="数据操作："><a href="#数据操作：" class="headerlink" title="数据操作："></a>数据操作：</h3><p>关系模型中常用的关系操作包括查询和数据更新两大部分：<br>查询: 选择、投影、连接、除、并、差、交、笛卡尔积等，其中选择、投影、并、差、笛卡尔积是5种基本操作<br>数据更新:插入、删除、修改<br>集合运算符：并、交、差、乘<br>专门运算符：选择、投影、连接、除<br>基本运算符：选择、投影、并、差、笛卡尔积</p><p>关系模型中常用的关系操作包括：选择（Select）、投影（Project）、连接（Join）、除（Divide）、并（Union）、交(Intersection）、差（Difference）等查询（Query）操作，和插入（Insert）、删除（Delete）、修改（Update）操作两大部分。查询是其中最主要的部分。<br>关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合（set-at-a-time）的方式。相应地，非关系数据模型的数据操作方式则为一次一记录（record-at-a-time）的方式。</p><h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><pre><code>关系的完整性规则是对关系的某种约束条件。</code></pre><p>（1）实体完整性，指在基本关系表中主码取值的约束，以保证每个元组可以被标识。约束规则：非空、唯一。<br>（2）参照完整性，指关系间需要遵循的数据约束，以保证关系间关联列的数据一致性。参照完整性是指外码取值必须与现有主码值相对应。<br>（3）用户定义完整性，指用户根据具体业务对数据处理规则要求所定义的数据约束。用户可定义列的数据类型、取值范围、缺省值、是否允许为空、取值唯一性、数据依赖性。</p><h3 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h3><p>   设F是基本关系R的一个或一组属性，但不是关系R的码，如果F与基本关系S的主码 Ks相对应，则称F是基本关系R的外码（Foreign key），并称基本关系R为参照关系（Referencing relation），基本关系S为被参照关系（Referenced relation）或目标关系（Target relation）。关系R和S不一定是不同的关系。</p><h3 id="简述-SQL-语言的特点"><a href="#简述-SQL-语言的特点" class="headerlink" title="简述 SQL 语言的特点"></a>简述 SQL 语言的特点</h3><p>SQL 语言集数据查询、数据操纵、数据定义和数据控制功能于一体，充分体现了关系数据库语言的特点和优点。其特点如下：①综合统一 ②高度非过程化 ③面向集合的操作方式 ④以同一种语法结构提供多种操作方式 ⑤语言简洁，易学易用</p><h3 id="SQL语言类别"><a href="#SQL语言类别" class="headerlink" title="SQL语言类别"></a>SQL语言类别</h3><p>（1）数据定义语言DDL（data definition language）:创建、删除、修改数据库对象（包括数据库、表、索引）   Create&#x2F;drop&#x2F;alter  database&#x2F;table&#x2F;index<br>（2）数据操纵语言DML（data manipulation language）:增加、删除、修改数据库<br>Insert、update、 delete<br>（3）数据查询语言DQL（data query language）:对数据库进行查询   select<br>（4）数据控制语言DCL（data control language）:对数据库对象访问权进行控制<br>Grant(授权)、 deny(拒绝)、 revoke(撤销)</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><pre><code>在数据库中，索引是针对某个表中的一列或者几列建立的指向表中记录数据页的逻辑指针清单，可加快对数据表的快速信息检索，快速连接关联表，减少分组和排序时间。</code></pre><p>聚集索引与非聚集索引的区别：在聚集索引中，码值的逻辑顺序决定了表中相应行的物理顺序；在非聚集索引中，码值的逻辑顺序可以与表中相应行的物理顺序不同。</p><h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><p>（1）简化复杂的SQL查询操作。通过视图，开发人员可以将复杂的查询语句封装在视图内，使外部程序只需要简单方式访问该视图，便可获取所需数据。<br>（2）提高数据访问安全性。通过视图可以将基本数据表的部分敏感数据隐藏起来，外部用户无法得知完整数据，保护隐私，并降低数据库被攻击的风险。<br>（3）提供一定程度是数据逻辑独立性。当数据表的结构改变，只要视图的结构不变，应用程序可以不做修改。<br>（4）集中展示用户所感兴趣的特定部分。<br>（5）使用户能以多种角度看待同一数据。</p><h3 id="SQL主码约束和唯一约束有什么区别呢？"><a href="#SQL主码约束和唯一约束有什么区别呢？" class="headerlink" title="SQL主码约束和唯一约束有什么区别呢？"></a>SQL主码约束和唯一约束有什么区别呢？</h3><p>主码约束：由一列或多列的组合，其值能唯一的标识表中的每一行。<br>唯一约束：不允许数据库表在指定列上具有相同的值，但允许有空值。<br>区别：一个表可以定义多个唯一约束，但只能定义一个主码约束；空值的列上可以定义唯一约束，不能定义主键约束。</p><h3 id="什么是表？什么是视图？两者的区别和联系是什么？"><a href="#什么是表？什么是视图？两者的区别和联系是什么？" class="headerlink" title="什么是表？什么是视图？两者的区别和联系是什么？"></a>什么是表？什么是视图？两者的区别和联系是什么？</h3><p>表是实实在在得保存数据的实体,写入的数据都保存在表中；<br>视图是从一个或几个基本表导出的表，它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。视图一经定义就可以像基本表一样被查询、删除，也可以在一个视图之上再定义新的视图，但是对视图的更新操作有限制。<br>联系： 视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。</p><h3 id="说明等值连接与自然连接的区别与联系？"><a href="#说明等值连接与自然连接的区别与联系？" class="headerlink" title="说明等值连接与自然连接的区别与联系？"></a>说明等值连接与自然连接的区别与联系？</h3><p>自然连接是除去重复属性的等值连接。 两者之间的区别和联系如下：<br>（1）自然连接一定是等值连接，但等值连接不一定是自然连接；<br>（2）等值连接要求相等的分量，不一定是公共属性；而自然连接要求相等的分量必须是公共属性；<br>（3）等值连接不把重复的属性除去；而自然连接要把重复的属性除去。</p><h3 id="数据字典通常包含五个部分：数据项、数据结构、数据流、数据存储、处理过程"><a href="#数据字典通常包含五个部分：数据项、数据结构、数据流、数据存储、处理过程" class="headerlink" title="数据字典通常包含五个部分：数据项、数据结构、数据流、数据存储、处理过程"></a>数据字典通常包含五个部分：数据项、数据结构、数据流、数据存储、处理过程</h3><h3 id="范式：1NF-2NF-3NF-BCNF-First-Normal-Form-Boycee-Codd-Normal-Form"><a href="#范式：1NF-2NF-3NF-BCNF-First-Normal-Form-Boycee-Codd-Normal-Form" class="headerlink" title="范式：1NF  2NF   3NF   BCNF    First Normal Form    Boycee Codd Normal Form"></a>范式：1NF  2NF   3NF   BCNF    First Normal Form    Boycee Codd Normal Form</h3><p>1NF：每个属性都不可再分<br>2NF：在1NF的基础之上，消除了非主属性对于码的部分函数依赖<br>3NF：在2NF的基础之上，消除了非主属性对于码的传递函数依赖<br>BCNF：在3NF的基础上，消除主属性对于码的部分函数依赖与传递函数依赖</p><p>1NF有哪些缺点？<br>1、数据冗余太大（每一个系的系主任名字重复出现）<br>2、更新异常（某个系更换系主任之后，必须将该系学生有关的每一个元组）<br>3、插入异常（如果一个系刚成立，尚无学生，就无法将老师存入到数据库中）<br>4、删除异常（如果学生都毕业了，在删除学生时，把这个系的系主任的所有信息都删除了）</p><h3 id="E-R模型到关系模型的转换"><a href="#E-R模型到关系模型的转换" class="headerlink" title="E-R模型到关系模型的转换"></a>E-R模型到关系模型的转换</h3><p>（1）将每一个实体转换成关系表，实体的属性转换为表的列，实体的标识符转换为表的主码；<br>（2）将实体间的关系转换为表间的参照完整性约束，即通过设置外码来参照主码。</p><h3 id="数据库管理员DBA的职责："><a href="#数据库管理员DBA的职责：" class="headerlink" title="数据库管理员DBA的职责："></a>数据库管理员DBA的职责：</h3><p>①决定数据库中的信息内容和结构：数据库中要存放哪些信息<br>②决定数据库的存储结构和存取策略：获得较高的存取效率和存储空间利用率<br>③定义数据的安全性要求和完整性约束条件：负责确定各个用户对数据库的存取权限、数<br>据的保密级别和完整性约束条件<br>④监控数据库的使用和运行：转储数据、维护日志文件、故障恢复<br>①数据库的改进和重组重构：对运行情况进行记录、统计分析，以此来不断改进数据库设计</p><h3 id="事务管理与事务"><a href="#事务管理与事务" class="headerlink" title="事务管理与事务"></a>事务管理与事务</h3><p>事务管理：在数据库应用系统中，完成一个业务处理通常需要多个操作步骤。在每个操作步骤中，都可能遭遇失败，若没有一个处理机制，就可能造成操作数据混乱，从而破坏数据一致性。<br>事务：指由构成单个业务处理单元的一组数据库访问操作，它们要么都正常执行，要么都不执行，是一个不可分割的工作单位。在关系数据库中，⼀个事务可以是⼀条SQL语句、⼀组SQL语句或者整个程序。事务通常以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。COMMIT表⽰提交，即提交事务 的所有操作。具体的说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。 ROLLBACK表⽰回滚，即在事务运⾏的过程中发⽣了某种故障，事务不能继续执⾏，系统将事务中对数据库的所 有已完成的操作全部撤销，回滚到事务开始时的状态。</p><p>事务ACID特性：<br>原子性（Atomicity）：事务的所有操作在数据库中要么全部执行，要么都不执行。<br>一致性（Consistency）：事务多次执行，结果应一致<br>隔离性（Isolation）：事务与事务之间隔离，并执行透明<br>持续性（Durability）：事务完成后，数据该改变必须是永久的</p><h3 id="为什么要进行数据库转储，比较各种数据转储方法？"><a href="#为什么要进行数据库转储，比较各种数据转储方法？" class="headerlink" title="为什么要进行数据库转储，比较各种数据转储方法？"></a>为什么要进行数据库转储，比较各种数据转储方法？</h3><p>所谓转储即DBA定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本称为后备副本或后援副本。当数据库遭到破坏后可以将后备副本重新装入，但重装后备副本只能将数据库恢复到转储时的状态，要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务。转储可分为静态转储和动态转储。转储还可以分为海量转储和增量转储两种方式。海量转储是指每次转储全部数据库。增量转储则指每次只转储上一次转储后更新过的数据。从恢复角度看，使用海量转储得到的后备副本进行恢复一般说来会更方便些。但如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效。</p><h3 id="并发控制可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？"><a href="#并发控制可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？" class="headerlink" title="并发控制可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？"></a>并发控制可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？</h3><p>并发操作带来的数据不一致性包括三类：丢失修改、不可重复读和读“脏”数据。产生数据不一致性的主要原因是并发操作破坏了事务的隔离性。并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其它事务的干扰，从而避免造成数据的不一致性。并发控制的主要技术是封锁（Locking）。<br>丢失修改：当一个事务修改了数据，并且这种修改还没有提交到数据库中时，另外一个事务又对同样的数据进行了修改，并且把这种修改提交到了数据库中。这样，数据库中没有出现第一个事务修改数据的结果，好像这种数据修改丢失了一样。<br>不可重复读：在一个事务内，多次读同一数据。在这个事务还没有结束时，另一个事务也访问该同一数据，那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，第一个事务两次读到的数据可能不一样。<br>读“脏”数据：当一个事务正在访问数据，并对数据进行了修改，而这种修改还没有提交到数据库中，这时另一个事务也访问这个数据并使用了这个数据。因为这个数据是还没有提交的数据，那么另一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p><h3 id="数据库完整性与安全性的区别"><a href="#数据库完整性与安全性的区别" class="headerlink" title="数据库完整性与安全性的区别"></a>数据库完整性与安全性的区别</h3><p>完整性和安全性是两个不同的概念。前者是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出造成的无效操作和错误结果，而后者是防止数据库被恶意的破坏和非法的存取。当然，完整性和安全性是密切相关的。特别是从系统实现的方法来看，某一种机制常常既可以用于安全保护亦可用于完整性保证。</p><h3 id="日志文件的定义与作用。"><a href="#日志文件的定义与作用。" class="headerlink" title="日志文件的定义与作用。"></a>日志文件的定义与作用。</h3><p>日志文件是用来记录事务对数据库的更新操作的文件。作用：在数据库恢复中起着重要的作用，可以用来进行事物故障恢复和系统故障恢复，并协助后备副本进行介质故障恢复。</p><h3 id="数据库恢复策略有哪几种？"><a href="#数据库恢复策略有哪几种？" class="headerlink" title="数据库恢复策略有哪几种？"></a>数据库恢复策略有哪几种？</h3><p>（1）数据转储（数据冗余）   （2）日志文件</p><h3 id="数据库：两段锁协议"><a href="#数据库：两段锁协议" class="headerlink" title="数据库：两段锁协议"></a>数据库：两段锁协议</h3><p>两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁。在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；在释放一个封锁之后，事务不再申请和获得任何其他封锁。<br>“两段”的含义是，事务分为两个阶段：第一阶段是获得封锁，也称为扩展阶段。在这阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁。第二阶段是释放封锁，也称为收缩阶段。在这阶段，事务释放已经获得的锁，但是不能再申请任何锁。<br>    可以证明，若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策 略都是可串行化的。 另外要注意两段锁协议和防止死锁的一次封锁法的异同之处。一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议；但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。</p><h3 id="数据库故障的种类？"><a href="#数据库故障的种类？" class="headerlink" title="数据库故障的种类？"></a>数据库故障的种类？</h3><p>1、事务内部的故障2、系统故障3、介质故障4、计算机病毒</p><h3 id="数据库保护-访问-的内容有哪些？"><a href="#数据库保护-访问-的内容有哪些？" class="headerlink" title="数据库保护(访问)的内容有哪些？"></a>数据库保护(访问)的内容有哪些？</h3><p>① 利用权限机制和完整性约束防止非法数据进入数据库；<br>② 提供故障恢复能力；<br>② 提供并发访问控制。</p><h3 id="数据库有哪几种备份策略"><a href="#数据库有哪几种备份策略" class="headerlink" title="数据库有哪几种备份策略"></a>数据库有哪几种备份策略</h3><p>完全备份、事务日志备份、差异备份、文件备份。</p><h3 id="DBMS-的控制操作有哪些"><a href="#DBMS-的控制操作有哪些" class="headerlink" title="DBMS 的控制操作有哪些"></a>DBMS 的控制操作有哪些</h3><p>①数据的安全性保护；②数据的完整性检查；③并发控制；④数据库恢复。</p><h3 id="DBMS的数据控制功能有那些"><a href="#DBMS的数据控制功能有那些" class="headerlink" title="DBMS的数据控制功能有那些"></a>DBMS的数据控制功能有那些</h3><p>（1）数据定义功能。DBMS提供相应数据语言来定义（DDL）数据库结构，它们是刻画数据库框架，并被保存在数据字典中。<br>（2）数据存取功能。DBMS提供数据操纵语言（DML），实现对数据库数据的基本存取操作：检索，插入，修改和删除。<br>（3）数据库运行管理功能。DBMS提供数据控制功能，即是数据的安全性、完整性和并发控制等对数据库运行进行有效地控制和管理，以确保数据正确有效。<br>（4）数据库的建立和维护功能。包括数据库初始数据的装入，数据库的转储、恢复、重组织，系统性能监视、分析等功能。<br>（5）数据库的传输。DBMS提供处理数据的传输，实现用户程序与DBMS之间的通信，通常与操作系统协调完成。</p><h3 id="Java语言设计数据库"><a href="#Java语言设计数据库" class="headerlink" title="Java语言设计数据库"></a>Java语言设计数据库</h3><p>创建数据库链结－&gt;创建语句对象－&gt;执行SQL命令-&gt;访问执行结果集-&gt;关闭链结<br>（1）利用JDBC API建立数据库连接，<br>（2）在建立的数据库连接上，执行SQL语句访问数据库<br>（3）在JSP中处理SQL执行结果<br>（4）在JSP中释放数据库连接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据库简答题&lt;/p&gt;
&lt;h3 id=&quot;典型数据库模型&quot;&gt;&lt;a href=&quot;#典型数据库模型&quot; class=&quot;headerlink&quot; title=&quot;典型数据库模型&quot;&gt;&lt;/a&gt;典型数据库模型&lt;/h3&gt;&lt;p&gt;层次数据模型、网状数据模型、关系数据模型、面向对象数据模型等&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="基础知识" scheme="https://wuchu.site/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="数据库基础" scheme="https://wuchu.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql中元组的隐藏字段与MVCC</title>
    <link href="https://wuchu.site/2024/08/07/mvcc/"/>
    <id>https://wuchu.site/2024/08/07/mvcc/</id>
    <published>2024-08-07T03:58:29.000Z</published>
    <updated>2024-10-28T16:25:43.155Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>看了两本书，对pg元组隐藏字段的描述都不太清楚，导致我很难理解隐藏字段值的变化原因，这里详细介绍隐藏一下pg中元组每个隐藏字段的意义。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>安装的pg版本为<code>11</code>，每个元组的头部信息在<code>HeapTupleHeaderData</code>中定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HeapTupleHeaderData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">HeapTupleFields t_heap; <span class="comment">//存放元组描述信息</span></span><br><span class="line">DatumTupleFields t_datum;</span><br><span class="line">&#125;t_choice;</span><br><span class="line"></span><br><span class="line">ItemPointerData t_ctid;<span class="comment">/*元组的存放位置，一般值为“（blockid,itemid）”  */</span></span><br><span class="line">uint16t_infomask2;<span class="comment">/* 属性和标识位 */</span></span><br><span class="line">uint16t_infomask;<span class="comment">/* 其他标识位 */</span></span><br><span class="line">uint8t_hoff;<span class="comment">/* 首部+位图+填充的长度 */</span></span><br><span class="line">bits8t_bits[<span class="number">1</span>];<span class="comment">/* bitmap of NULLs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>HeapTupleHeaderData中的<code>t_heap</code>存储着元组的一些描述信息，结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HeapTupleFields</span></span><br><span class="line">&#123;</span><br><span class="line">TransactionId t_xmin;   <span class="comment">/* 插入或修改事务的ID */</span></span><br><span class="line">TransactionId t_xmax;   <span class="comment">/* 删除或者锁定事务的ID */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">   CommandId t_cid;   <span class="comment">/* 插入或者删除的命令ID */</span></span><br><span class="line">   TransactionId t_xvac; <span class="comment">/* 执行vacuum full的事务ID */</span></span><br><span class="line">&#125;    t_field3;</span><br><span class="line">&#125; HeapTupleFields;</span><br></pre></td></tr></table></figure><p>经过分析源码，发现核心的隐藏字段有：<strong>t_ctid、t_xmin、t_xmax、t_cid</strong></p><p>执行命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> attname, attnum, attisdropped, attlen, attalign, attnotnull</span><br><span class="line"><span class="keyword">FROM</span> pg_catalog.pg_attribute <span class="keyword">WHERE</span> attrelid <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span>::regclass</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> attnum;</span><br></pre></td></tr></table></figure><p>发现实际表的隐藏字段如下所示：</p><img src="/2024/08/07/mvcc/image.png" class="" title="图一"><p>所以说源码中的字段跟实际隐藏字段的name有区别，对应关系：</p><table><thead><tr><th>源码字段</th><th>实际隐藏字段</th></tr></thead><tbody><tr><td>t_ctid</td><td>ctid</td></tr><tr><td>t_xmin</td><td>xmin</td></tr><tr><td>t_xmax</td><td>xmax</td></tr><tr><td>t_cid</td><td>cmax、cmin</td></tr></tbody></table><h3 id="隐藏字段详细分析"><a href="#隐藏字段详细分析" class="headerlink" title="隐藏字段详细分析"></a>隐藏字段详细分析</h3><h5 id="t-ctid"><a href="#t-ctid" class="headerlink" title="t_ctid"></a>t_ctid</h5><img src="/2024/08/07/mvcc/image.2.png" class="" title="图2️"> <img src="/2024/08/07/mvcc/image.4.png" class="" title="图3"><p>对应实际字段中的ctid，表示数据记录的物理行当信息，指的是一条记录位于哪个数据块的哪个位移上面。<br>格式<code>(blockid,itemid)</code>：拿上图其中的(0,1)来说；0表示块id；1表示在这块第一条记录。</p><ul><li><p><strong>当执行insert操作时，ctid的变化如下：</strong></p><img src="/2024/08/07/mvcc/image.5.png" class="" title="图4"><img src="/2024/08/07/mvcc/image.6.png" class="" title="图5"><p>看出来是顺序累加。</p></li><li><p><strong>当执行更新操作时，ctid的变化：</strong></p><img src="/2024/08/07/mvcc/image.7.png" class="" title="图6"><img src="/2024/08/07/mvcc/image.8.png" class="" title="图7"><img src="/2024/08/07/mvcc/image.11.png" class="" title="图8"><p>更新操作实际上就是先删除一条数据，再插入一条数据。但是这个删除并不会移除物理存储内容，也就是说（0，2）这个位置的元组还在，因此新插入的数据的ctid为（0，3）。<br>如果执行vacuum操作，再插入一条数据：</p><img src="/2024/08/07/mvcc/image.9.png" class="" title="图9"></li></ul><blockquote><p><strong>发现并不会在（0，2）位置上插入新数据？</strong><br><strong>分析：</strong>新插入的数据通常不会立即填充刚刚清理的空间，而是优先使用表末尾的空闲空间，这涉及到数据库的存储管理和性能优化策略。减少碎片化：优先使用表末尾的空闲空间可以减少数据文件的碎片化，提高查询性能。提高插入性能：插入新数据到表末尾的空闲空间比在表中间找到一个合适的空闲位置更高效。</p></blockquote><h5 id="t-xmin"><a href="#t-xmin" class="headerlink" title="t_xmin"></a>t_xmin</h5><p>存储的是产生这个元组的事务ID，可能是insert或者update语句</p><img src="/2024/08/07/mvcc/image.12.png" class="" title="图10"><h5 id="t-xmax"><a href="#t-xmax" class="headerlink" title="t_xmax"></a>t_xmax</h5><p>存储的是删除或者锁定这个元组的事务ID</p><h5 id="t-cid"><a href="#t-cid" class="headerlink" title="t_cid"></a>t_cid</h5><p>包含cmin和cmax两个字段，分别存储创建这个元组的Command ID和删除这个元组的Command ID。在事务执行期间，会给改期间执行的所以命令设置一个唯一ID，也就是Command ID。</p><h3 id="MVCC的可见性判断"><a href="#MVCC的可见性判断" class="headerlink" title="MVCC的可见性判断"></a>MVCC的可见性判断</h3><p>MVCC 可见性判断主要就是将元组的 xmin、xmax、cmin、cmax 以及 t_infomask 信息结合快照 snapshot 以及 CLOG 中的信息，根据可见性判断规则，决定一个元组是否可见。<br>可见性判断主要分为两个部分：</p><ul><li>对元组的 xmin 进行可见性判断，即 insert 该元组的事务是否已提交，是否可见。</li><li>对元组的 xmax 进行可见性判断，即该元组是否已被 update 或者 delete。</li></ul><p>为了简化逻辑，去除了一些兼容相关的干扰以及很少走到的一些代码路径。以下是关于元组 xmin 的判断规则：</p><p>1.如果元组 xmin 未提交，判断条件为：!(t_infomask &amp; HEAP_XMIN_COMMITTED)</p><p>1.1 如果元组的 xmin 无效，即 HeapTupleHeaderXminInvalid(tuple)，返回不可见</p><p>1.2 如果元组的 xmin 在当前事务（包含子事务）中</p><ul><li>1.2.1 如果元组的 cmin 大于等于 快照的 commandId，返回不可见</li><li>1.2.2 如果元组的 t_infomask 包含 HEAP_XMAX_INVALID 标记，即 xmax 无效，返回可见</li><li>1.2.3 如果元组的 t_infomask 仅包含 HEAP_XMAX_EXCL_LOCK，返回可见</li><li>1.2.4 如果元组的 xmax 不在当前事务中，设置标记 HEAP_XMAX_INVALID，返回可见</li><li>1.2.5 如果元组的 cmax 大于等于快照的 commandId，返回可见，否则返回不可见</li></ul><p>1.3 如果元组的 xmin 在快照的活跃事务列表中，返回不可见</p><p>1.4 如果元组的 xmin 在 clog 中已提交，设置标记 HEAP_XMIN_COMMITTED</p><p>1.5 设置标记 HEAP_XMIN_INVALID，返回不可见</p><p>2.如果元组的 xmin 已提交</p><p>2.1 如果元组的 xmin 未冻结并且 xmin 在快照活跃事务列表中，返回不可见</p><p><strong>到此说明元组的 xmin 已提交，即 insert 已提交，是否可见还得看 xmax，下面是关于 xmax 的判断规则</strong></p><p>3.t_infomask 标记包含 HEAP_XMAX_INVALID，返回可见</p><p>4.t_infomask 标记满足 HEAP_XMAX_IS_LOCKED_ONLY，返回可见</p><p>5.如果 t_infomask 不包含 HEAP_XMAX_COMMITTED</p><p>5.1 如果 xmax 在当前事务中</p><ul><li>5.1.1 cmax 大于等于快照的cid，返回可见</li><li>5.1.2 cmax 小于快照的 cid，返回不可见</li></ul><p>5.2 如果 xmax 在快照的活跃事务列表中，返回可见</p><p>5.3 如果 xmax 在 clog 中没有提交，设置标记 HEAP_XMAX_INVALID，返回可见</p><p>5.4 设置标记 HEAP_XMAX_COMMITTED</p><p>6.t_infomask 包含 HEAP_XMAX_COMMITTED</p><p>6.1 如果 xmax 在快照的活跃事务列表中，返回可见</p><p>除了以上描述的情况外，其他的都返回不可见</p><p>7.其他都是返回不可见</p><p>以上分析可以看出 MVCC 可见性判断的规则还是比较复杂的，考虑了很多场景，规则之间还有先后顺序依赖。总结可见性规则影响因素如下：</p><ul><li>xmin 是否已提交，是否有效</li><li>xmin 是否在当前会话的事务中</li><li>xmin 是否在快照活跃事务列表中</li><li>xmin 在 clog 中的状态</li><li>cmin 与 快照 cid 的大小比较</li><li>xmax 是否已提交，是否有效</li><li>xmax 是否在当前会话的事务中</li><li>xmax 是否在快照活跃事务列表中</li><li>xmax 在 clog 中的状态</li><li>cmax 与快照 cid 的大小比较</li></ul><p>关于可见性分析，有两点需要注意：</p><ol><li>即使是 select 查询，也可能会写 wal 日志，比如设置 HEAP_XMIN_COMMITTED 这个操作就会涉及写 wal 日志。</li><li>此外即使 insert 事务已提交，已经写入 CLOG，但是该事务的事务号还没有从活跃事务列表中删除，那么元组仍然是不可见的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;看了两本书，对pg元组隐藏字段的描述都不太清楚，导致我很难理解隐藏字段值的变化原因，这里详细介绍隐藏一下pg中元组每个隐藏字段的意义。&lt;/p</summary>
      
    
    
    
    <category term="原理" scheme="https://wuchu.site/categories/%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="MVCC" scheme="https://wuchu.site/tags/MVCC/"/>
    
    <category term="postgresql" scheme="https://wuchu.site/tags/postgresql/"/>
    
  </entry>
  
</feed>
